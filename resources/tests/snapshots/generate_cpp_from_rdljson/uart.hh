
/*
 * File autogenerated by the test.
 */

#pragma once
/* The `platform.hh` should be created and include the specific platform header which will contain the device addresses.*/
#include  "platform.hh" 
#include  "mmio.hh" 
namespace mmio {
namespace uart {

/* Interrupt State Register */
union IntrStateReg { 
    private:
      zermio::Register reg_;
    public:
    /* raised if the transmit FIFO is past the high-water mark. */
    zermio::BitField<0, 1, zermio::Permissions::Read> tx_watermark;
    /* raised if the receive FIFO is past the high-water mark. */
    zermio::BitField<1, 1, zermio::Permissions::Read> rx_watermark;
    /* raised if the transmit FIFO has emptied and no transmit is ongoing. */
    zermio::BitField<2, 1, zermio::Permissions::ReadWrite> tx_done;
    /* raised if the receive FIFO has overflowed. */
    zermio::BitField<3, 1, zermio::Permissions::ReadWrite> rx_overflow;
    /* raised if a framing error has been detected on receive. */
    zermio::BitField<4, 1, zermio::Permissions::ReadWrite> rx_frame_err;
    /* raised if break condition has been detected on receive. */
    zermio::BitField<5, 1, zermio::Permissions::ReadWrite> rx_break_err;
    /* raised if RX FIFO has characters remaining in the FIFO without beingretrieved for the programmed time period. */
    zermio::BitField<6, 1, zermio::Permissions::ReadWrite> rx_timeout;
    /* raised if the receiver has detected a parity error. */
    zermio::BitField<7, 1, zermio::Permissions::ReadWrite> rx_parity_err;
    /* raised if the transmit FIFO is empty. */
    zermio::BitField<8, 1, zermio::Permissions::Read> tx_empty;
    constexpr IntrStateReg (uintptr_t addr): reg_{.addr = addr}
    {}

    inline void commit() { reg_.commit(); }

    inline IntrStateReg& fetch() {
        reg_.fetch();
        return *this;
    }
};



/* Interrupt Enable Register */
union IntrEnableReg { 
    private:
      zermio::Register reg_;
    public:
    /* Enable interrupt when !!INTR_STATE.tx_watermark is set. */
    zermio::BitField<0, 1, zermio::Permissions::ReadWrite> tx_watermark;
    /* Enable interrupt when !!INTR_STATE.rx_watermark is set. */
    zermio::BitField<1, 1, zermio::Permissions::ReadWrite> rx_watermark;
    /* Enable interrupt when !!INTR_STATE.tx_done is set. */
    zermio::BitField<2, 1, zermio::Permissions::ReadWrite> tx_done;
    /* Enable interrupt when !!INTR_STATE.rx_overflow is set. */
    zermio::BitField<3, 1, zermio::Permissions::ReadWrite> rx_overflow;
    /* Enable interrupt when !!INTR_STATE.rx_frame_err is set. */
    zermio::BitField<4, 1, zermio::Permissions::ReadWrite> rx_frame_err;
    /* Enable interrupt when !!INTR_STATE.rx_break_err is set. */
    zermio::BitField<5, 1, zermio::Permissions::ReadWrite> rx_break_err;
    /* Enable interrupt when !!INTR_STATE.rx_timeout is set. */
    zermio::BitField<6, 1, zermio::Permissions::ReadWrite> rx_timeout;
    /* Enable interrupt when !!INTR_STATE.rx_parity_err is set. */
    zermio::BitField<7, 1, zermio::Permissions::ReadWrite> rx_parity_err;
    /* Enable interrupt when !!INTR_STATE.tx_empty is set. */
    zermio::BitField<8, 1, zermio::Permissions::ReadWrite> tx_empty;
    constexpr IntrEnableReg (uintptr_t addr): reg_{.addr = addr}
    {}

    inline void commit() { reg_.commit(); }

    inline IntrEnableReg& fetch() {
        reg_.fetch();
        return *this;
    }
};



/* Interrupt Test Register */
union IntrTestReg { 
    private:
      zermio::Register reg_;
    public:
    /* Write 1 to force !!INTR_STATE.tx_watermark to 1. */
    zermio::BitField<0, 1, zermio::Permissions::Write> tx_watermark;
    /* Write 1 to force !!INTR_STATE.rx_watermark to 1. */
    zermio::BitField<1, 1, zermio::Permissions::Write> rx_watermark;
    /* Write 1 to force !!INTR_STATE.tx_done to 1. */
    zermio::BitField<2, 1, zermio::Permissions::Write> tx_done;
    /* Write 1 to force !!INTR_STATE.rx_overflow to 1. */
    zermio::BitField<3, 1, zermio::Permissions::Write> rx_overflow;
    /* Write 1 to force !!INTR_STATE.rx_frame_err to 1. */
    zermio::BitField<4, 1, zermio::Permissions::Write> rx_frame_err;
    /* Write 1 to force !!INTR_STATE.rx_break_err to 1. */
    zermio::BitField<5, 1, zermio::Permissions::Write> rx_break_err;
    /* Write 1 to force !!INTR_STATE.rx_timeout to 1. */
    zermio::BitField<6, 1, zermio::Permissions::Write> rx_timeout;
    /* Write 1 to force !!INTR_STATE.rx_parity_err to 1. */
    zermio::BitField<7, 1, zermio::Permissions::Write> rx_parity_err;
    /* Write 1 to force !!INTR_STATE.tx_empty to 1. */
    zermio::BitField<8, 1, zermio::Permissions::Write> tx_empty;
    constexpr IntrTestReg (uintptr_t addr): reg_{.addr = addr}
    {}

    inline void commit() { reg_.commit(); }

    inline IntrTestReg& fetch() {
        reg_.fetch();
        return *this;
    }
};



/* UART control register */
union CtrlReg { 
    private:
      zermio::Register reg_;
    public:
    /* TX enable */
    zermio::BitField<0, 1, zermio::Permissions::ReadWrite> tx;
    /* RX enable */
    zermio::BitField<1, 1, zermio::Permissions::ReadWrite> rx;
    /* RX noise filter enable.If the noise filter is enabled, RX line goes through the 3-taprepetition code. It ignores single IP clock period noise. */
    zermio::BitField<2, 1, zermio::Permissions::ReadWrite> nf;
    /* System loopback enable.If this bit is turned on, any outgoing bits to TX are received through RX.See Block Diagram. Note that the TX line goes 1 if System loopback is enabled. */
    zermio::BitField<4, 1, zermio::Permissions::ReadWrite> slpbk;
    /* Line loopback enable.If this bit is turned on, incoming bits are forwarded to TX for testing purpose.See Block Diagram. Note that the internal design sees RX value as 1 always if lineloopback is enabled. */
    zermio::BitField<5, 1, zermio::Permissions::ReadWrite> llpbk;
    /* If true, parity is enabled in both RX and TX directions. */
    zermio::BitField<6, 1, zermio::Permissions::ReadWrite> parity_en;
    /* If PARITY_EN is true, this determines the type, 1 for odd parity, 0 for even. */
    zermio::BitField<7, 1, zermio::Permissions::ReadWrite> parity_odd;
    /* Trigger level for RX break detection. Sets the number of charactertimes the line must be low to detect a break. */
    zermio::BitField<8, 2, zermio::Permissions::ReadWrite> rxblvl;
    /* BAUD clock rate control. */
    zermio::BitField<16, 16, zermio::Permissions::ReadWrite> nco;
    constexpr CtrlReg (uintptr_t addr): reg_{.addr = addr}
    {}

    inline void commit() { reg_.commit(); }

    inline CtrlReg& fetch() {
        reg_.fetch();
        return *this;
    }
};



/* UART live status register */
union StatusReg { 
    private:
      zermio::Register reg_;
    public:
    /* TX buffer is full */
    zermio::BitField<0, 1, zermio::Permissions::Read> txfull;
    /* RX buffer is full */
    zermio::BitField<1, 1, zermio::Permissions::Read> rxfull;
    /* TX FIFO is empty */
    zermio::BitField<2, 1, zermio::Permissions::Read> txempty;
    /* TX FIFO is empty and all bits have been transmitted */
    zermio::BitField<3, 1, zermio::Permissions::Read> txidle;
    /* RX is idle */
    zermio::BitField<4, 1, zermio::Permissions::Read> rxidle;
    /* RX FIFO is empty */
    zermio::BitField<5, 1, zermio::Permissions::Read> rxempty;
    constexpr StatusReg (uintptr_t addr): reg_{.addr = addr}
    {}

    inline void commit() { reg_.commit(); }

    inline StatusReg& fetch() {
        reg_.fetch();
        return *this;
    }
};



/* UART read data */
union RdataReg { 
    private:
      zermio::Register reg_;
    public:
    /*  */
    zermio::BitField<0, 8, zermio::Permissions::Read> rdata;
    constexpr RdataReg (uintptr_t addr): reg_{.addr = addr}
    {}

    inline void commit() { reg_.commit(); }

    inline RdataReg& fetch() {
        reg_.fetch();
        return *this;
    }
};



/* UART write data */
union WdataReg { 
    private:
      zermio::Register reg_;
    public:
    /*  */
    zermio::BitField<0, 8, zermio::Permissions::Write> wdata;
    constexpr WdataReg (uintptr_t addr): reg_{.addr = addr}
    {}

    inline void commit() { reg_.commit(); }

    inline WdataReg& fetch() {
        reg_.fetch();
        return *this;
    }
};



/* UART FIFO control register */
union FifoCtrlReg { 
    private:
      zermio::Register reg_;
    public:
    /* RX fifo reset. Write 1 to the register resets RX_FIFO. Read returns 0 */
    zermio::BitField<0, 1, zermio::Permissions::Write> rxrst;
    /* TX fifo reset. Write 1 to the register resets TX_FIFO. Read returns 0 */
    zermio::BitField<1, 1, zermio::Permissions::Write> txrst;
    /* Trigger level for RX interrupts. If the FIFO depth is greater than or equal tothe setting, it raises rx_watermark interrupt. */
    zermio::BitField<2, 3, zermio::Permissions::ReadWrite> rxilvl;
    /* Trigger level for TX interrupts. If the FIFO depth is less than the setting, itraises tx_watermark interrupt. */
    zermio::BitField<5, 3, zermio::Permissions::ReadWrite> txilvl;
    constexpr FifoCtrlReg (uintptr_t addr): reg_{.addr = addr}
    {}

    inline void commit() { reg_.commit(); }

    inline FifoCtrlReg& fetch() {
        reg_.fetch();
        return *this;
    }
};



/* UART FIFO status register */
union FifoStatusReg { 
    private:
      zermio::Register reg_;
    public:
    /* Current fill level of TX fifo */
    zermio::BitField<0, 8, zermio::Permissions::Read> txlvl;
    /* Current fill level of RX fifo */
    zermio::BitField<16, 8, zermio::Permissions::Read> rxlvl;
    constexpr FifoStatusReg (uintptr_t addr): reg_{.addr = addr}
    {}

    inline void commit() { reg_.commit(); }

    inline FifoStatusReg& fetch() {
        reg_.fetch();
        return *this;
    }
};



/* TX pin override control. Gives direct SW control over TX pin state */
union OvrdReg { 
    private:
      zermio::Register reg_;
    public:
    /* Enable TX pin override control */
    zermio::BitField<0, 1, zermio::Permissions::ReadWrite> txen;
    /* Write to set the value of the TX pin */
    zermio::BitField<1, 1, zermio::Permissions::ReadWrite> txval;
    constexpr OvrdReg (uintptr_t addr): reg_{.addr = addr}
    {}

    inline void commit() { reg_.commit(); }

    inline OvrdReg& fetch() {
        reg_.fetch();
        return *this;
    }
};



/* UART oversampled values */
union ValReg { 
    private:
      zermio::Register reg_;
    public:
    /* Last 16 oversampled values of RX. Most recent bit is bit 0, oldest 15. */
    zermio::BitField<0, 16, zermio::Permissions::Read> rx;
    constexpr ValReg (uintptr_t addr): reg_{.addr = addr}
    {}

    inline void commit() { reg_.commit(); }

    inline ValReg& fetch() {
        reg_.fetch();
        return *this;
    }
};



/* UART RX timeout control */
union TimeoutCtrlReg { 
    private:
      zermio::Register reg_;
    public:
    /* RX timeout value in UART bit times */
    zermio::BitField<0, 24, zermio::Permissions::ReadWrite> val;
    /* Enable RX timeout feature */
    zermio::BitField<31, 1, zermio::Permissions::ReadWrite> en;
    constexpr TimeoutCtrlReg (uintptr_t addr): reg_{.addr = addr}
    {}

    inline void commit() { reg_.commit(); }

    inline TimeoutCtrlReg& fetch() {
        reg_.fetch();
        return *this;
    }
};



/* To facilitate compiler optimization of this abstraction, prefer using this struct within a small scope.*/
struct Uart {
    IntrStateReg intr_state;
    IntrEnableReg intr_enable;
    IntrTestReg intr_test;
    CtrlReg ctrl;
    StatusReg status;
    RdataReg rdata;
    WdataReg wdata;
    FifoCtrlReg fifo_ctrl;
    FifoStatusReg fifo_status;
    OvrdReg ovrd;
    ValReg val;
    TimeoutCtrlReg timeout_ctrl;
    
    constexpr Uart (platform::Uart addr):
        intr_state(addr + 0x0), 
        intr_enable(addr + 0x4), 
        intr_test(addr + 0x8), 
        ctrl(addr + 0x10), 
        status(addr + 0x14), 
        rdata(addr + 0x18), 
        wdata(addr + 0x1c), 
        fifo_ctrl(addr + 0x20), 
        fifo_status(addr + 0x24), 
        ovrd(addr + 0x28), 
        val(addr + 0x2c), 
        timeout_ctrl(addr + 0x30){}
};


} // namespace uart
} // namespace mmio
