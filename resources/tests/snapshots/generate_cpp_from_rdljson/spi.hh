
/*
 * File autogenerated by the test.
 */

#pragma once
/* The `platform.hh` should be created and include the specific platform header which will contain the device addresses.*/
#include  "platform.hh" 
#include  "mmio.hh" 
namespace mmio {
namespace spi {

/* Interrupt State Register */
union IntrStateReg { 
    private:
      zermio::Register reg_;
    public:
    /* Receive FIFO is full */
    zermio::BitField<0, 1, zermio::Permissions::Read> rx_full;
    /* Receive FIFO level is at or above watermark */
    zermio::BitField<1, 1, zermio::Permissions::Read> rx_watermark;
    /* Transmit FIFO is empty */
    zermio::BitField<2, 1, zermio::Permissions::Read> tx_empty;
    /* Transmit FIFO level is at or below watermark */
    zermio::BitField<3, 1, zermio::Permissions::Read> tx_watermark;
    /* On-going SPI operation has completed and the block is now idle */
    zermio::BitField<4, 1, zermio::Permissions::ReadWrite> complete;
    constexpr IntrStateReg (uintptr_t addr): reg_{.addr = addr}
    {}

    inline void commit() { reg_.commit(); }

    inline IntrStateReg& fetch() {
        reg_.fetch();
        return *this;
    }
};



/* Interrupt Enable Register */
union IntrEnableReg { 
    private:
      zermio::Register reg_;
    public:
    /* Enable interrupt when !!INTR_STATE.rx_full is set. */
    zermio::BitField<0, 1, zermio::Permissions::ReadWrite> rx_full;
    /* Enable interrupt when !!INTR_STATE.rx_watermark is set. */
    zermio::BitField<1, 1, zermio::Permissions::ReadWrite> rx_watermark;
    /* Enable interrupt when !!INTR_STATE.tx_empty is set. */
    zermio::BitField<2, 1, zermio::Permissions::ReadWrite> tx_empty;
    /* Enable interrupt when !!INTR_STATE.tx_watermark is set. */
    zermio::BitField<3, 1, zermio::Permissions::ReadWrite> tx_watermark;
    /* Enable interrupt when !!INTR_STATE.complete is set. */
    zermio::BitField<4, 1, zermio::Permissions::ReadWrite> complete;
    constexpr IntrEnableReg (uintptr_t addr): reg_{.addr = addr}
    {}

    inline void commit() { reg_.commit(); }

    inline IntrEnableReg& fetch() {
        reg_.fetch();
        return *this;
    }
};



/* Interrupt Test Register */
union IntrTestReg { 
    private:
      zermio::Register reg_;
    public:
    /* Write 1 to force !!INTR_STATE.rx_full to 1. */
    zermio::BitField<0, 1, zermio::Permissions::Write> rx_full;
    /* Write 1 to force !!INTR_STATE.rx_watermark to 1. */
    zermio::BitField<1, 1, zermio::Permissions::Write> rx_watermark;
    /* Write 1 to force !!INTR_STATE.tx_empty to 1. */
    zermio::BitField<2, 1, zermio::Permissions::Write> tx_empty;
    /* Write 1 to force !!INTR_STATE.tx_watermark to 1. */
    zermio::BitField<3, 1, zermio::Permissions::Write> tx_watermark;
    /* Write 1 to force !!INTR_STATE.complete to 1. */
    zermio::BitField<4, 1, zermio::Permissions::Write> complete;
    constexpr IntrTestReg (uintptr_t addr): reg_{.addr = addr}
    {}

    inline void commit() { reg_.commit(); }

    inline IntrTestReg& fetch() {
        reg_.fetch();
        return *this;
    }
};



/* Configuration register. Controls how the SPI block transmits   and receives data. This register can only be modified   whilst the SPI block is idle. */
union CfgReg { 
    private:
      zermio::Register reg_;
    public:
    /* The length of a half period (i.e. positive edge to negative   edge) of the SPI clock, measured in system clock cycles   reduced by 1. At the standard Sonata 50 MHz system clock a   value of 0 gives a 25 MHz SPI clock, a value of 1 gives a   12.5 MHz SPI clock, a value of 2 gives a 8.33 MHz SPI clock   and so on. */
    zermio::BitField<0, 16, zermio::Permissions::ReadWrite> half_clk_period;
    /* State of the controller output line (COPI) when not transmitting. */
    zermio::BitField<28, 1, zermio::Permissions::ReadWrite> copi_idle;
    /* When set the most significant bit (MSB) is the first bit   sent and received with each byte */
    zermio::BitField<29, 1, zermio::Permissions::ReadWrite> msb_first;
    /* The phase of the spi_clk signal. When CPHA is 0 data is   sampled on the leading edge and changes on the trailing   edge. The first data bit is immediately available before   the first leading edge of the clock when transmission   begins. When CPHA is 1 data is sampled on the trailing edge   and change on the leading edge. */
    zermio::BitField<30, 1, zermio::Permissions::ReadWrite> cpha;
    /* The polarity of the spi_clk signal. When CPOL is 0 clock is   low when idle and the leading edge is positive. When CPOL   is 1 clock is high when idle and the leading edge is   negative */
    zermio::BitField<31, 1, zermio::Permissions::ReadWrite> cpol;
    constexpr CfgReg (uintptr_t addr): reg_{.addr = addr}
    {}

    inline void commit() { reg_.commit(); }

    inline CfgReg& fetch() {
        reg_.fetch();
        return *this;
    }
};



/* Controls the operation of the SPI block. This register can   only be modified whilst the SPI block is idle. */
union ControlReg { 
    private:
      zermio::Register reg_;
    public:
    /* Write 1 to clear the transmit FIFO */
    zermio::BitField<0, 1, zermio::Permissions::Write> tx_clear;
    /* Write 1 to clear the receive FIFO */
    zermio::BitField<1, 1, zermio::Permissions::Write> rx_clear;
    /* When set bytes from the transmit FIFO are sent. When clear   the state of the outgoing spi_copi is undefined whilst the   SPI clock is running. */
    zermio::BitField<2, 1, zermio::Permissions::ReadWrite> tx_enable;
    /* When set incoming bits are written to the receive FIFO.   When clear incoming bits are ignored. */
    zermio::BitField<3, 1, zermio::Permissions::ReadWrite> rx_enable;
    /* The watermark level for the transmit FIFO, depending on the   value the interrupt will trigger at different points:    * 0 - 1 or fewer items in the FIFO    * 1 - 2 or fewer items in the FIFO    * 2 - 4 or fewer items in the FIFO    * 3 - 8 or fewer items in the FIFO    * 4 - 16 or fewer items in the FIFO */
    zermio::BitField<4, 4, zermio::Permissions::ReadWrite> tx_watermark;
    /* The watermark level for the receive FIFO, depending on the   value the interrupt will trigger at different points:    * 0 - 1 or more items in the FIFO    * 1 - 2 or more items in the FIFO    * 2 - 4 or more items in the FIFO    * 3 - 8 or more items in the FIFO    * 4 - 16 or more items in the FIFO    * 5 - 32 or more items in the FIFO    * 6 - 56 or more items in the FIFO */
    zermio::BitField<8, 4, zermio::Permissions::ReadWrite> rx_watermark;
    /* When set the CIPO line is internally connected to the COPI line,   providing loopback functionality which may be useful in testing.   Note that the COPI line is unaffected and still carries data so   test software should normally leave the CS lines deasserted.   This bit shall be changed only when the SPI core is idle. */
    zermio::BitField<30, 1, zermio::Permissions::ReadWrite> int_loopback;
    /* When a 1 is written to this field a reset of the controller logic   is performed.   This shall be used only to recover from error conditions.   The TX FIFO shall be cleared before resetting the controller logic;   then clear the RX FIFO after the controller reset.   The bit self-clears and always reads as zero. */
    zermio::BitField<31, 1, zermio::Permissions::Write> sw_reset;
    constexpr ControlReg (uintptr_t addr): reg_{.addr = addr}
    {}

    inline void commit() { reg_.commit(); }

    inline ControlReg& fetch() {
        reg_.fetch();
        return *this;
    }
};



/* Status information about the SPI block */
union StatusReg { 
    private:
      zermio::Register reg_;
    public:
    /* Number of items in the transmit FIFO */
    zermio::BitField<0, 8, zermio::Permissions::Read> tx_fifo_level;
    /* Number of items in the receive FIFO */
    zermio::BitField<8, 8, zermio::Permissions::Read> rx_fifo_level;
    /* When set the transmit FIFO is full and any data written to it   will be ignored. */
    zermio::BitField<16, 1, zermio::Permissions::Read> tx_fifo_full;
    /* When set the receive FIFO is empty and any data read from it   will be undefined. */
    zermio::BitField<17, 1, zermio::Permissions::Read> rx_fifo_empty;
    /* When set the SPI block is idle and can accept a new start   command. */
    zermio::BitField<18, 1, zermio::Permissions::Read> idle;
    constexpr StatusReg (uintptr_t addr): reg_{.addr = addr}
    {}

    inline void commit() { reg_.commit(); }

    inline StatusReg& fetch() {
        reg_.fetch();
        return *this;
    }
};



/* When written begins an SPI operation. Writes are ignored when the   SPI block is active. */
union StartReg { 
    private:
      zermio::Register reg_;
    public:
    /* Number of bytes to receive/transmit in the SPI operation */
    zermio::BitField<0, 11, zermio::Permissions::Write> byte_count;
    constexpr StartReg (uintptr_t addr): reg_{.addr = addr}
    {}

    inline void commit() { reg_.commit(); }

    inline StartReg& fetch() {
        reg_.fetch();
        return *this;
    }
};



/* Data from the receive FIFO. When read the data is popped from the   FIFO. If the FIFO is empty data read is undefined. */
union RxFifoReg { 
    private:
      zermio::Register reg_;
    public:
    /* Byte popped from the FIFO */
    zermio::BitField<0, 8, zermio::Permissions::Read> data;
    constexpr RxFifoReg (uintptr_t addr): reg_{.addr = addr}
    {}

    inline void commit() { reg_.commit(); }

    inline RxFifoReg& fetch() {
        reg_.fetch();
        return *this;
    }
};



/* Bytes written here are pushed to the transmit FIFO. If the FIFO   is full writes are ignored. */
union TxFifoReg { 
    private:
      zermio::Register reg_;
    public:
    /* Byte to push to the FIFO */
    zermio::BitField<0, 8, zermio::Permissions::Write> data;
    constexpr TxFifoReg (uintptr_t addr): reg_{.addr = addr}
    {}

    inline void commit() { reg_.commit(); }

    inline TxFifoReg& fetch() {
        reg_.fetch();
        return *this;
    }
};



/* Returns information on the SPI controller. */
union InfoReg { 
    private:
      zermio::Register reg_;
    public:
    /* Maximum number of items in the transmit FIFO. */
    zermio::BitField<0, 8, zermio::Permissions::Read> tx_fifo_depth;
    /* Maximum number of items in the receive FIFO. */
    zermio::BitField<8, 8, zermio::Permissions::Read> rx_fifo_depth;
    constexpr InfoReg (uintptr_t addr): reg_{.addr = addr}
    {}

    inline void commit() { reg_.commit(); }

    inline InfoReg& fetch() {
        reg_.fetch();
        return *this;
    }
};



/* Specifies which peripherals are selected for transmit/receive operations.   An operation may select multiple peripherals simultaneously but this functionality   shall be used only for transmit operations.   This register shall be changed only when the SPI controller is idle, not whilst   a transmit/receive operation may be in progress. */
union CsReg { 
    private:
      zermio::Register reg_;
    public:
    /* If this bit is clear the peripheral is selected for transmit/receive operations. */
    zermio::BitField<0, 1, zermio::Permissions::ReadWrite> cs_0;
    /* If this bit is clear the peripheral is selected for transmit/receive operations. */
    zermio::BitField<1, 1, zermio::Permissions::ReadWrite> cs_1;
    /* If this bit is clear the peripheral is selected for transmit/receive operations. */
    zermio::BitField<2, 1, zermio::Permissions::ReadWrite> cs_2;
    /* If this bit is clear the peripheral is selected for transmit/receive operations. */
    zermio::BitField<3, 1, zermio::Permissions::ReadWrite> cs_3;
    constexpr CsReg (uintptr_t addr): reg_{.addr = addr}
    {}

    inline void commit() { reg_.commit(); }

    inline CsReg& fetch() {
        reg_.fetch();
        return *this;
    }
};



/* To facilitate compiler optimization of this abstraction, prefer using this struct within a small scope.*/
struct Spi {
    IntrStateReg intr_state;
    IntrEnableReg intr_enable;
    IntrTestReg intr_test;
    CfgReg cfg;
    ControlReg control;
    StatusReg status;
    StartReg start;
    RxFifoReg rx_fifo;
    TxFifoReg tx_fifo;
    InfoReg info;
    CsReg cs;
    
    constexpr Spi (platform::Spi addr):
        intr_state(addr + 0x0), 
        intr_enable(addr + 0x4), 
        intr_test(addr + 0x8), 
        cfg(addr + 0xc), 
        control(addr + 0x10), 
        status(addr + 0x14), 
        start(addr + 0x18), 
        rx_fifo(addr + 0x1c), 
        tx_fifo(addr + 0x20), 
        info(addr + 0x24), 
        cs(addr + 0x28){}
};


} // namespace spi
} // namespace mmio
