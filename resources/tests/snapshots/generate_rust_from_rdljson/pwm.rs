
/*
 * File autogenerated by the test.
 */

//zermio


//! These are the registers present in the pwm 
//! | Register name      | Description  | Offset | Write | Read| 
//! | :---               | :---         | :---   | :--   | :-- |
//! | WIDTH |  | 0x0 | true |true |
//! | COUNTER |  | 0x4 | true |true |

use super::zermio;
/// ``` rust
/// pwm.width.update(|width| {
///     if width.value().read() == 1 {
///        width.value().write(0);
///     }
/// });
/// ```
pub struct Pwm {
    ///   
    pub width : width::Width,
    ///   
    pub counter : counter::Counter,
}

impl Pwm {
    pub fn new(instance: u32) -> Self {
    let addr = instance as u32;
      Self {
        width : width::Width::new(addr + 0x0 ),
        counter : counter::Counter::new(addr + 0x4 ),
      }
  }
}



/// .  
pub use self::width::*;
mod width {

  use super::*;

  /// # WIDTH fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | value | Pwm width. | [31:0] | true |true |
  pub struct Width {
    reg: zermio::Register<u32>,
  }

  impl Width {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Pwm width.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn value(&mut self) -> ValueField {
        ValueField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type ValueField<'a> = zermio::BitField<'a, 0, 32, u32, zermio::access::ReadWrite>;
}



/// .  
pub use self::counter::*;
mod counter {

  use super::*;

  /// # COUNTER fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | value | Pwm counter. | [31:0] | true |true |
  pub struct Counter {
    reg: zermio::Register<u32>,
  }

  impl Counter {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Pwm counter.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn value(&mut self) -> ValueField {
        ValueField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type ValueField<'a> = zermio::BitField<'a, 0, 32, u32, zermio::access::ReadWrite>;
}
