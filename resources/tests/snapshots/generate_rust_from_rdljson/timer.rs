
/*
 * File autogenerated by the test.
 */

//zermio


//! These are the registers present in the timer 
//! | Register name      | Description  | Offset | Write | Read| 
//! | :---               | :---         | :---   | :--   | :-- |
//! | MTIMEL |  | 0x0 | true |true |
//! | MTIMEH |  | 0x4 | true |true |
//! | MTIMECMPL |  | 0x8 | true |true |
//! | MTIMECMPH |  | 0xc | true |true |

use super::zermio;
/// ``` rust
/// timer.mtimel.update(|mtimel| {
///     if mtimel.value().read() == 1 {
///        mtimel.value().write(0);
///     }
/// });
/// ```
pub struct Timer {
    ///   
    pub mtimel : mtimel::Mtimel,
    ///   
    pub mtimeh : mtimeh::Mtimeh,
    ///   
    pub mtimecmpl : mtimecmpl::Mtimecmpl,
    ///   
    pub mtimecmph : mtimecmph::Mtimecmph,
}

impl Timer {
    pub fn new(instance: u32) -> Self {
    let addr = instance as u32;
      Self {
        mtimel : mtimel::Mtimel::new(addr + 0x0 ),
        mtimeh : mtimeh::Mtimeh::new(addr + 0x4 ),
        mtimecmpl : mtimecmpl::Mtimecmpl::new(addr + 0x8 ),
        mtimecmph : mtimecmph::Mtimecmph::new(addr + 0xc ),
      }
  }
}



/// .  
pub use self::mtimel::*;
mod mtimel {

  use super::*;

  /// # MTIMEL fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | VALUE | mtime low | [31:0] | true |true |
  pub struct Mtimel {
    reg: zermio::Register<u32>,
  }

  impl Mtimel {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: mtime low
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn value(&mut self) -> ValueField {
        ValueField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type ValueField<'a> = zermio::BitField<'a, 0, 32, u32, zermio::access::ReadWrite>;
}



/// .  
pub use self::mtimeh::*;
mod mtimeh {

  use super::*;

  /// # MTIMEH fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | VALUE | mtime high | [31:0] | true |true |
  pub struct Mtimeh {
    reg: zermio::Register<u32>,
  }

  impl Mtimeh {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: mtime high
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn value(&mut self) -> ValueField {
        ValueField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type ValueField<'a> = zermio::BitField<'a, 0, 32, u32, zermio::access::ReadWrite>;
}



/// .  
pub use self::mtimecmpl::*;
mod mtimecmpl {

  use super::*;

  /// # MTIMECMPL fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | value | mtime cmp low | [31:0] | true |true |
  pub struct Mtimecmpl {
    reg: zermio::Register<u32>,
  }

  impl Mtimecmpl {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: mtime cmp low
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn value(&mut self) -> ValueField {
        ValueField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type ValueField<'a> = zermio::BitField<'a, 0, 32, u32, zermio::access::ReadWrite>;
}



/// .  
pub use self::mtimecmph::*;
mod mtimecmph {

  use super::*;

  /// # MTIMECMPH fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | value | mtime cmp high | [31:0] | true |true |
  pub struct Mtimecmph {
    reg: zermio::Register<u32>,
  }

  impl Mtimecmph {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: mtime cmp high
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn value(&mut self) -> ValueField {
        ValueField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type ValueField<'a> = zermio::BitField<'a, 0, 32, u32, zermio::access::ReadWrite>;
}
