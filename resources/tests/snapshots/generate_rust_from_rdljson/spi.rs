
/*
 * File autogenerated by the test.
 */

//zermio


//! These are the registers present in the spi 
//! | Register name      | Description  | Offset | Write | Read| 
//! | :---               | :---         | :---   | :--   | :-- |
//! | INTR_STATE | Interrupt State Register | 0x0 | true |true |
//! | INTR_ENABLE | Interrupt Enable Register | 0x4 | true |true |
//! | INTR_TEST | Interrupt Test Register | 0x8 | true |false |
//! | CFG | Configuration register. Controls how the SPI block transmits   and receives data. This register can only be modified   whilst the SPI block is idle. | 0xc | true |true |
//! | CONTROL | Controls the operation of the SPI block. This register can   only be modified whilst the SPI block is idle. | 0x10 | true |true |
//! | STATUS | Status information about the SPI block | 0x14 | false |true |
//! | START | When written begins an SPI operation. Writes are ignored when the   SPI block is active. | 0x18 | true |false |
//! | RX_FIFO | Data from the receive FIFO. When read the data is popped from the   FIFO. If the FIFO is empty data read is undefined. | 0x1c | false |true |
//! | TX_FIFO | Bytes written here are pushed to the transmit FIFO. If the FIFO   is full writes are ignored. | 0x20 | true |false |
//! | INFO | Returns information on the SPI controller. | 0x24 | false |true |
//! | CS | Specifies which peripherals are selected for transmit/receive operations.   An operation may select multiple peripherals simultaneously but this functionality   shall be used only for transmit operations.   This register shall be changed only when the SPI controller is idle, not whilst   a transmit/receive operation may be in progress. | 0x28 | true |true |

use super::zermio;
/// ``` rust
/// spi.intr_state.update(|intr_state| {
///     if intr_state.rx_full().read() == 1 {
///        intr_state.rx_full().write(0);
///     }
/// });
/// ```
pub struct Spi {
    /// Interrupt State Register  
    pub intr_state : intr_state::IntrState,
    /// Interrupt Enable Register  
    pub intr_enable : intr_enable::IntrEnable,
    /// Interrupt Test Register  
    pub intr_test : intr_test::IntrTest,
    /// Configuration register. Controls how the SPI block transmits   and receives data. This register can only be modified   whilst the SPI block is idle.  
    pub cfg : cfg::Cfg,
    /// Controls the operation of the SPI block. This register can   only be modified whilst the SPI block is idle.  
    pub control : control::Control,
    /// Status information about the SPI block  
    pub status : status::Status,
    /// When written begins an SPI operation. Writes are ignored when the   SPI block is active.  
    pub start : start::Start,
    /// Data from the receive FIFO. When read the data is popped from the   FIFO. If the FIFO is empty data read is undefined.  
    pub rx_fifo : rx_fifo::RxFifo,
    /// Bytes written here are pushed to the transmit FIFO. If the FIFO   is full writes are ignored.  
    pub tx_fifo : tx_fifo::TxFifo,
    /// Returns information on the SPI controller.  
    pub info : info::Info,
    /// Specifies which peripherals are selected for transmit/receive operations.   An operation may select multiple peripherals simultaneously but this functionality   shall be used only for transmit operations.   This register shall be changed only when the SPI controller is idle, not whilst   a transmit/receive operation may be in progress.  
    pub cs : cs::Cs,
}

impl Spi {
    pub fn new(instance: u32) -> Self {
    let addr = instance as u32;
      Self {
        intr_state : intr_state::IntrState::new(addr + 0x0 ),
        intr_enable : intr_enable::IntrEnable::new(addr + 0x4 ),
        intr_test : intr_test::IntrTest::new(addr + 0x8 ),
        cfg : cfg::Cfg::new(addr + 0xc ),
        control : control::Control::new(addr + 0x10 ),
        status : status::Status::new(addr + 0x14 ),
        start : start::Start::new(addr + 0x18 ),
        rx_fifo : rx_fifo::RxFifo::new(addr + 0x1c ),
        tx_fifo : tx_fifo::TxFifo::new(addr + 0x20 ),
        info : info::Info::new(addr + 0x24 ),
        cs : cs::Cs::new(addr + 0x28 ),
      }
  }
}



/// Interrupt State Register.  
pub use self::intr_state::*;
mod intr_state {

  use super::*;

  /// # INTR_STATE fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | RX_FULL | Receive FIFO is full | [0:0] | false |true |
  /// | RX_WATERMARK | Receive FIFO level is at or above watermark | [1:1] | false |true |
  /// | TX_EMPTY | Transmit FIFO is empty | [2:2] | false |true |
  /// | TX_WATERMARK | Transmit FIFO level is at or below watermark | [3:3] | false |true |
  /// | COMPLETE | On-going SPI operation has completed and the block is now idle | [4:4] | true |true |
  pub struct IntrState {
    reg: zermio::Register<u32>,
  }

  impl IntrState {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Receive FIFO is full
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_full(&mut self) -> RxFullField {
        RxFullField::new(&mut self.reg)
    }

  /// Hardware description: Receive FIFO level is at or above watermark
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_watermark(&mut self) -> RxWatermarkField {
        RxWatermarkField::new(&mut self.reg)
    }

  /// Hardware description: Transmit FIFO is empty
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tx_empty(&mut self) -> TxEmptyField {
        TxEmptyField::new(&mut self.reg)
    }

  /// Hardware description: Transmit FIFO level is at or below watermark
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tx_watermark(&mut self) -> TxWatermarkField {
        TxWatermarkField::new(&mut self.reg)
    }

  /// Hardware description: On-going SPI operation has completed and the block is now idle
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn complete(&mut self) -> CompleteField {
        CompleteField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type RxFullField<'a> = zermio::BitField<'a, 0, 1, u32, zermio::access::Read>;
  type RxWatermarkField<'a> = zermio::BitField<'a, 1, 1, u32, zermio::access::Read>;
  type TxEmptyField<'a> = zermio::BitField<'a, 2, 1, u32, zermio::access::Read>;
  type TxWatermarkField<'a> = zermio::BitField<'a, 3, 1, u32, zermio::access::Read>;
  type CompleteField<'a> = zermio::BitField<'a, 4, 1, u32, zermio::access::ReadWrite>;
}



/// Interrupt Enable Register.  
pub use self::intr_enable::*;
mod intr_enable {

  use super::*;

  /// # INTR_ENABLE fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | RX_FULL | Enable interrupt when !!INTR_STATE.rx_full is set. | [0:0] | true |true |
  /// | RX_WATERMARK | Enable interrupt when !!INTR_STATE.rx_watermark is set. | [1:1] | true |true |
  /// | TX_EMPTY | Enable interrupt when !!INTR_STATE.tx_empty is set. | [2:2] | true |true |
  /// | TX_WATERMARK | Enable interrupt when !!INTR_STATE.tx_watermark is set. | [3:3] | true |true |
  /// | COMPLETE | Enable interrupt when !!INTR_STATE.complete is set. | [4:4] | true |true |
  pub struct IntrEnable {
    reg: zermio::Register<u32>,
  }

  impl IntrEnable {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Enable interrupt when !!INTR_STATE.rx_full is set.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_full(&mut self) -> RxFullField {
        RxFullField::new(&mut self.reg)
    }

  /// Hardware description: Enable interrupt when !!INTR_STATE.rx_watermark is set.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_watermark(&mut self) -> RxWatermarkField {
        RxWatermarkField::new(&mut self.reg)
    }

  /// Hardware description: Enable interrupt when !!INTR_STATE.tx_empty is set.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tx_empty(&mut self) -> TxEmptyField {
        TxEmptyField::new(&mut self.reg)
    }

  /// Hardware description: Enable interrupt when !!INTR_STATE.tx_watermark is set.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tx_watermark(&mut self) -> TxWatermarkField {
        TxWatermarkField::new(&mut self.reg)
    }

  /// Hardware description: Enable interrupt when !!INTR_STATE.complete is set.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn complete(&mut self) -> CompleteField {
        CompleteField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type RxFullField<'a> = zermio::BitField<'a, 0, 1, u32, zermio::access::ReadWrite>;
  type RxWatermarkField<'a> = zermio::BitField<'a, 1, 1, u32, zermio::access::ReadWrite>;
  type TxEmptyField<'a> = zermio::BitField<'a, 2, 1, u32, zermio::access::ReadWrite>;
  type TxWatermarkField<'a> = zermio::BitField<'a, 3, 1, u32, zermio::access::ReadWrite>;
  type CompleteField<'a> = zermio::BitField<'a, 4, 1, u32, zermio::access::ReadWrite>;
}



/// Interrupt Test Register.  
pub use self::intr_test::*;
mod intr_test {

  use super::*;

  /// # INTR_TEST fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | RX_FULL | Write 1 to force !!INTR_STATE.rx_full to 1. | [0:0] | true |false |
  /// | RX_WATERMARK | Write 1 to force !!INTR_STATE.rx_watermark to 1. | [1:1] | true |false |
  /// | TX_EMPTY | Write 1 to force !!INTR_STATE.tx_empty to 1. | [2:2] | true |false |
  /// | TX_WATERMARK | Write 1 to force !!INTR_STATE.tx_watermark to 1. | [3:3] | true |false |
  /// | COMPLETE | Write 1 to force !!INTR_STATE.complete to 1. | [4:4] | true |false |
  pub struct IntrTest {
    reg: zermio::Register<u32>,
  }

  impl IntrTest {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Write 1 to force !!INTR_STATE.rx_full to 1.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_full(&mut self) -> RxFullField {
        RxFullField::new(&mut self.reg)
    }

  /// Hardware description: Write 1 to force !!INTR_STATE.rx_watermark to 1.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_watermark(&mut self) -> RxWatermarkField {
        RxWatermarkField::new(&mut self.reg)
    }

  /// Hardware description: Write 1 to force !!INTR_STATE.tx_empty to 1.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tx_empty(&mut self) -> TxEmptyField {
        TxEmptyField::new(&mut self.reg)
    }

  /// Hardware description: Write 1 to force !!INTR_STATE.tx_watermark to 1.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tx_watermark(&mut self) -> TxWatermarkField {
        TxWatermarkField::new(&mut self.reg)
    }

  /// Hardware description: Write 1 to force !!INTR_STATE.complete to 1.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn complete(&mut self) -> CompleteField {
        CompleteField::new(&mut self.reg)
    }

    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
  }
  type RxFullField<'a> = zermio::BitField<'a, 0, 1, u32, zermio::access::Write>;
  type RxWatermarkField<'a> = zermio::BitField<'a, 1, 1, u32, zermio::access::Write>;
  type TxEmptyField<'a> = zermio::BitField<'a, 2, 1, u32, zermio::access::Write>;
  type TxWatermarkField<'a> = zermio::BitField<'a, 3, 1, u32, zermio::access::Write>;
  type CompleteField<'a> = zermio::BitField<'a, 4, 1, u32, zermio::access::Write>;
}



/// Configuration register. Controls how the SPI block transmits   and receives data. This register can only be modified   whilst the SPI block is idle..  
pub use self::cfg::*;
mod cfg {

  use super::*;

  /// # CFG fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | HALF_CLK_PERIOD | The length of a half period (i.e. positive edge to negative   edge) of the SPI clock, measured in system clock cycles   reduced by 1. At the standard Sonata 50 MHz system clock a   value of 0 gives a 25 MHz SPI clock, a value of 1 gives a   12.5 MHz SPI clock, a value of 2 gives a 8.33 MHz SPI clock   and so on. | [15:0] | true |true |
  /// | COPI_IDLE | State of the controller output line (COPI) when not transmitting. | [28:28] | true |true |
  /// | MSB_FIRST | When set the most significant bit (MSB) is the first bit   sent and received with each byte | [29:29] | true |true |
  /// | CPHA | The phase of the spi_clk signal. When CPHA is 0 data is   sampled on the leading edge and changes on the trailing   edge. The first data bit is immediately available before   the first leading edge of the clock when transmission   begins. When CPHA is 1 data is sampled on the trailing edge   and change on the leading edge. | [30:30] | true |true |
  /// | CPOL | The polarity of the spi_clk signal. When CPOL is 0 clock is   low when idle and the leading edge is positive. When CPOL   is 1 clock is high when idle and the leading edge is   negative | [31:31] | true |true |
  pub struct Cfg {
    reg: zermio::Register<u32>,
  }

  impl Cfg {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: The length of a half period (i.e. positive edge to negative   edge) of the SPI clock, measured in system clock cycles   reduced by 1. At the standard Sonata 50 MHz system clock a   value of 0 gives a 25 MHz SPI clock, a value of 1 gives a   12.5 MHz SPI clock, a value of 2 gives a 8.33 MHz SPI clock   and so on.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn half_clk_period(&mut self) -> HalfClkPeriodField {
        HalfClkPeriodField::new(&mut self.reg)
    }

  /// Hardware description: State of the controller output line (COPI) when not transmitting.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn copi_idle(&mut self) -> CopiIdleField {
        CopiIdleField::new(&mut self.reg)
    }

  /// Hardware description: When set the most significant bit (MSB) is the first bit   sent and received with each byte
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn msb_first(&mut self) -> MsbFirstField {
        MsbFirstField::new(&mut self.reg)
    }

  /// Hardware description: The phase of the spi_clk signal. When CPHA is 0 data is   sampled on the leading edge and changes on the trailing   edge. The first data bit is immediately available before   the first leading edge of the clock when transmission   begins. When CPHA is 1 data is sampled on the trailing edge   and change on the leading edge.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn cpha(&mut self) -> CphaField {
        CphaField::new(&mut self.reg)
    }

  /// Hardware description: The polarity of the spi_clk signal. When CPOL is 0 clock is   low when idle and the leading edge is positive. When CPOL   is 1 clock is high when idle and the leading edge is   negative
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn cpol(&mut self) -> CpolField {
        CpolField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type HalfClkPeriodField<'a> = zermio::BitField<'a, 0, 16, u32, zermio::access::ReadWrite>;
  type CopiIdleField<'a> = zermio::BitField<'a, 28, 1, u32, zermio::access::ReadWrite>;
  type MsbFirstField<'a> = zermio::BitField<'a, 29, 1, u32, zermio::access::ReadWrite>;
  type CphaField<'a> = zermio::BitField<'a, 30, 1, u32, zermio::access::ReadWrite>;
  type CpolField<'a> = zermio::BitField<'a, 31, 1, u32, zermio::access::ReadWrite>;
}



/// Controls the operation of the SPI block. This register can   only be modified whilst the SPI block is idle..  
pub use self::control::*;
mod control {

  use super::*;

  /// # CONTROL fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | TX_CLEAR | Write 1 to clear the transmit FIFO | [0:0] | true |false |
  /// | RX_CLEAR | Write 1 to clear the receive FIFO | [1:1] | true |false |
  /// | TX_ENABLE | When set bytes from the transmit FIFO are sent. When clear   the state of the outgoing spi_copi is undefined whilst the   SPI clock is running. | [2:2] | true |true |
  /// | RX_ENABLE | When set incoming bits are written to the receive FIFO.   When clear incoming bits are ignored. | [3:3] | true |true |
  /// | TX_WATERMARK | The watermark level for the transmit FIFO, depending on the   value the interrupt will trigger at different points:    * 0 - 1 or fewer items in the FIFO    * 1 - 2 or fewer items in the FIFO    * 2 - 4 or fewer items in the FIFO    * 3 - 8 or fewer items in the FIFO    * 4 - 16 or fewer items in the FIFO | [7:4] | true |true |
  /// | RX_WATERMARK | The watermark level for the receive FIFO, depending on the   value the interrupt will trigger at different points:    * 0 - 1 or more items in the FIFO    * 1 - 2 or more items in the FIFO    * 2 - 4 or more items in the FIFO    * 3 - 8 or more items in the FIFO    * 4 - 16 or more items in the FIFO    * 5 - 32 or more items in the FIFO    * 6 - 56 or more items in the FIFO | [11:8] | true |true |
  /// | INT_LOOPBACK | When set the CIPO line is internally connected to the COPI line,   providing loopback functionality which may be useful in testing.   Note that the COPI line is unaffected and still carries data so   test software should normally leave the CS lines deasserted.   This bit shall be changed only when the SPI core is idle. | [30:30] | true |true |
  /// | SW_RESET | When a 1 is written to this field a reset of the controller logic   is performed.   This shall be used only to recover from error conditions.   The TX FIFO shall be cleared before resetting the controller logic;   then clear the RX FIFO after the controller reset.   The bit self-clears and always reads as zero. | [31:31] | true |false |
  pub struct Control {
    reg: zermio::Register<u32>,
  }

  impl Control {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Write 1 to clear the transmit FIFO
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tx_clear(&mut self) -> TxClearField {
        TxClearField::new(&mut self.reg)
    }

  /// Hardware description: Write 1 to clear the receive FIFO
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_clear(&mut self) -> RxClearField {
        RxClearField::new(&mut self.reg)
    }

  /// Hardware description: When set bytes from the transmit FIFO are sent. When clear   the state of the outgoing spi_copi is undefined whilst the   SPI clock is running.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tx_enable(&mut self) -> TxEnableField {
        TxEnableField::new(&mut self.reg)
    }

  /// Hardware description: When set incoming bits are written to the receive FIFO.   When clear incoming bits are ignored.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_enable(&mut self) -> RxEnableField {
        RxEnableField::new(&mut self.reg)
    }

  /// Hardware description: The watermark level for the transmit FIFO, depending on the   value the interrupt will trigger at different points:    * 0 - 1 or fewer items in the FIFO    * 1 - 2 or fewer items in the FIFO    * 2 - 4 or fewer items in the FIFO    * 3 - 8 or fewer items in the FIFO    * 4 - 16 or fewer items in the FIFO
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tx_watermark(&mut self) -> TxWatermarkField {
        TxWatermarkField::new(&mut self.reg)
    }

  /// Hardware description: The watermark level for the receive FIFO, depending on the   value the interrupt will trigger at different points:    * 0 - 1 or more items in the FIFO    * 1 - 2 or more items in the FIFO    * 2 - 4 or more items in the FIFO    * 3 - 8 or more items in the FIFO    * 4 - 16 or more items in the FIFO    * 5 - 32 or more items in the FIFO    * 6 - 56 or more items in the FIFO
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_watermark(&mut self) -> RxWatermarkField {
        RxWatermarkField::new(&mut self.reg)
    }

  /// Hardware description: When set the CIPO line is internally connected to the COPI line,   providing loopback functionality which may be useful in testing.   Note that the COPI line is unaffected and still carries data so   test software should normally leave the CS lines deasserted.   This bit shall be changed only when the SPI core is idle.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn int_loopback(&mut self) -> IntLoopbackField {
        IntLoopbackField::new(&mut self.reg)
    }

  /// Hardware description: When a 1 is written to this field a reset of the controller logic   is performed.   This shall be used only to recover from error conditions.   The TX FIFO shall be cleared before resetting the controller logic;   then clear the RX FIFO after the controller reset.   The bit self-clears and always reads as zero.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn sw_reset(&mut self) -> SwResetField {
        SwResetField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type TxClearField<'a> = zermio::BitField<'a, 0, 1, u32, zermio::access::Write>;
  type RxClearField<'a> = zermio::BitField<'a, 1, 1, u32, zermio::access::Write>;
  type TxEnableField<'a> = zermio::BitField<'a, 2, 1, u32, zermio::access::ReadWrite>;
  type RxEnableField<'a> = zermio::BitField<'a, 3, 1, u32, zermio::access::ReadWrite>;
  type TxWatermarkField<'a> = zermio::BitField<'a, 4, 4, u32, zermio::access::ReadWrite>;
  type RxWatermarkField<'a> = zermio::BitField<'a, 8, 4, u32, zermio::access::ReadWrite>;
  type IntLoopbackField<'a> = zermio::BitField<'a, 30, 1, u32, zermio::access::ReadWrite>;
  type SwResetField<'a> = zermio::BitField<'a, 31, 1, u32, zermio::access::Write>;
}



/// Status information about the SPI block.  
pub use self::status::*;
mod status {

  use super::*;

  /// # STATUS fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | TX_FIFO_LEVEL | Number of items in the transmit FIFO | [7:0] | false |true |
  /// | RX_FIFO_LEVEL | Number of items in the receive FIFO | [15:8] | false |true |
  /// | TX_FIFO_FULL | When set the transmit FIFO is full and any data written to it   will be ignored. | [16:16] | false |true |
  /// | RX_FIFO_EMPTY | When set the receive FIFO is empty and any data read from it   will be undefined. | [17:17] | false |true |
  /// | IDLE | When set the SPI block is idle and can accept a new start   command. | [18:18] | false |true |
  pub struct Status {
    reg: zermio::Register<u32>,
  }

  impl Status {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Number of items in the transmit FIFO
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tx_fifo_level(&mut self) -> TxFifoLevelField {
        TxFifoLevelField::new(&mut self.reg)
    }

  /// Hardware description: Number of items in the receive FIFO
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_fifo_level(&mut self) -> RxFifoLevelField {
        RxFifoLevelField::new(&mut self.reg)
    }

  /// Hardware description: When set the transmit FIFO is full and any data written to it   will be ignored.
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tx_fifo_full(&mut self) -> TxFifoFullField {
        TxFifoFullField::new(&mut self.reg)
    }

  /// Hardware description: When set the receive FIFO is empty and any data read from it   will be undefined.
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_fifo_empty(&mut self) -> RxFifoEmptyField {
        RxFifoEmptyField::new(&mut self.reg)
    }

  /// Hardware description: When set the SPI block is idle and can accept a new start   command.
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn idle(&mut self) -> IdleField {
        IdleField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
  }
  type TxFifoLevelField<'a> = zermio::BitField<'a, 0, 8, u32, zermio::access::Read>;
  type RxFifoLevelField<'a> = zermio::BitField<'a, 8, 8, u32, zermio::access::Read>;
  type TxFifoFullField<'a> = zermio::BitField<'a, 16, 1, u32, zermio::access::Read>;
  type RxFifoEmptyField<'a> = zermio::BitField<'a, 17, 1, u32, zermio::access::Read>;
  type IdleField<'a> = zermio::BitField<'a, 18, 1, u32, zermio::access::Read>;
}



/// When written begins an SPI operation. Writes are ignored when the   SPI block is active..  
pub use self::start::*;
mod start {

  use super::*;

  /// # START fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | BYTE_COUNT | Number of bytes to receive/transmit in the SPI operation | [10:0] | true |false |
  pub struct Start {
    reg: zermio::Register<u32>,
  }

  impl Start {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Number of bytes to receive/transmit in the SPI operation
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn byte_count(&mut self) -> ByteCountField {
        ByteCountField::new(&mut self.reg)
    }

    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
  }
  type ByteCountField<'a> = zermio::BitField<'a, 0, 11, u32, zermio::access::Write>;
}



/// Data from the receive FIFO. When read the data is popped from the   FIFO. If the FIFO is empty data read is undefined..  
pub use self::rx_fifo::*;
mod rx_fifo {

  use super::*;

  /// # RX_FIFO fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | DATA | Byte popped from the FIFO | [7:0] | false |true |
  pub struct RxFifo {
    reg: zermio::Register<u32>,
  }

  impl RxFifo {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Byte popped from the FIFO
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn data(&mut self) -> DataField {
        DataField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
  }
  type DataField<'a> = zermio::BitField<'a, 0, 8, u32, zermio::access::Read>;
}



/// Bytes written here are pushed to the transmit FIFO. If the FIFO   is full writes are ignored..  
pub use self::tx_fifo::*;
mod tx_fifo {

  use super::*;

  /// # TX_FIFO fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | DATA | Byte to push to the FIFO | [7:0] | true |false |
  pub struct TxFifo {
    reg: zermio::Register<u32>,
  }

  impl TxFifo {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Byte to push to the FIFO
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn data(&mut self) -> DataField {
        DataField::new(&mut self.reg)
    }

    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
  }
  type DataField<'a> = zermio::BitField<'a, 0, 8, u32, zermio::access::Write>;
}



/// Returns information on the SPI controller..  
pub use self::info::*;
mod info {

  use super::*;

  /// # INFO fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | TX_FIFO_DEPTH | Maximum number of items in the transmit FIFO. | [7:0] | false |true |
  /// | RX_FIFO_DEPTH | Maximum number of items in the receive FIFO. | [15:8] | false |true |
  pub struct Info {
    reg: zermio::Register<u32>,
  }

  impl Info {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Maximum number of items in the transmit FIFO.
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tx_fifo_depth(&mut self) -> TxFifoDepthField {
        TxFifoDepthField::new(&mut self.reg)
    }

  /// Hardware description: Maximum number of items in the receive FIFO.
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_fifo_depth(&mut self) -> RxFifoDepthField {
        RxFifoDepthField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
  }
  type TxFifoDepthField<'a> = zermio::BitField<'a, 0, 8, u32, zermio::access::Read>;
  type RxFifoDepthField<'a> = zermio::BitField<'a, 8, 8, u32, zermio::access::Read>;
}



/// Specifies which peripherals are selected for transmit/receive operations.   An operation may select multiple peripherals simultaneously but this functionality   shall be used only for transmit operations.   This register shall be changed only when the SPI controller is idle, not whilst   a transmit/receive operation may be in progress..  
pub use self::cs::*;
mod cs {

  use super::*;

  /// # CS fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | CS_0 | If this bit is clear the peripheral is selected for transmit/receive operations. | [0:0] | true |true |
  /// | CS_1 | If this bit is clear the peripheral is selected for transmit/receive operations. | [1:1] | true |true |
  /// | CS_2 | If this bit is clear the peripheral is selected for transmit/receive operations. | [2:2] | true |true |
  /// | CS_3 | If this bit is clear the peripheral is selected for transmit/receive operations. | [3:3] | true |true |
  pub struct Cs {
    reg: zermio::Register<u32>,
  }

  impl Cs {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: If this bit is clear the peripheral is selected for transmit/receive operations.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn cs_0(&mut self) -> Cs0Field {
        Cs0Field::new(&mut self.reg)
    }

  /// Hardware description: If this bit is clear the peripheral is selected for transmit/receive operations.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn cs_1(&mut self) -> Cs1Field {
        Cs1Field::new(&mut self.reg)
    }

  /// Hardware description: If this bit is clear the peripheral is selected for transmit/receive operations.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn cs_2(&mut self) -> Cs2Field {
        Cs2Field::new(&mut self.reg)
    }

  /// Hardware description: If this bit is clear the peripheral is selected for transmit/receive operations.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn cs_3(&mut self) -> Cs3Field {
        Cs3Field::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type Cs0Field<'a> = zermio::BitField<'a, 0, 1, u32, zermio::access::ReadWrite>;
  type Cs1Field<'a> = zermio::BitField<'a, 1, 1, u32, zermio::access::ReadWrite>;
  type Cs2Field<'a> = zermio::BitField<'a, 2, 1, u32, zermio::access::ReadWrite>;
  type Cs3Field<'a> = zermio::BitField<'a, 3, 1, u32, zermio::access::ReadWrite>;
}
