
/*
 * File autogenerated by the test.
 */

//zermio


//! These are the registers present in the xadc 
//! | Register name      | Description  | Offset | Write | Read| 
//! | :---               | :---         | :---   | :--   | :-- |
//! | CONFIG0 |  | 0x40 | true |true |
//! | CONFIG1 |  | 0x41 | true |true |
//! | CONFIG2 |  | 0x42 | true |true |
//! | TEST_REG0 |  | 0x43 | true |true |
//! | TEST_REG1 |  | 0x44 | true |true |
//! | TEST_REG2 |  | 0x45 | true |true |
//! | TEST_REG3 |  | 0x46 | true |true |

use super::zermio;
/// ``` rust
/// xadc.config0.update(|config0| {
///     if config0.cfg().read() == 1 {
///        config0.cfg().write(0);
///     }
/// });
/// ```
pub struct Xadc {
    ///   
    pub config0 : config::Config,
    ///   
    pub config1 : config::Config,
    ///   
    pub config2 : config::Config,
    ///   
    pub test_reg0 : test_reg::TestReg,
    ///   
    pub test_reg1 : test_reg::TestReg,
    ///   
    pub test_reg2 : test_reg::TestReg,
    ///   
    pub test_reg3 : test_reg::TestReg,
}

impl Xadc {
    pub fn new(instance: u32) -> Self {
    let addr = instance as u32;
      Self {
        config0 : config0::Config0::new(addr + 0x40 ),
        config1 : config1::Config1::new(addr + 0x41 ),
        config2 : config2::Config2::new(addr + 0x42 ),
        test_reg0 : test_reg0::TestReg0::new(addr + 0x43 ),
        test_reg1 : test_reg1::TestReg1::new(addr + 0x44 ),
        test_reg2 : test_reg2::TestReg2::new(addr + 0x45 ),
        test_reg3 : test_reg3::TestReg3::new(addr + 0x46 ),
      }
  }
}



/// .  
pub use self::config::*;
mod config {

  use super::*;

  /// # CONFIG fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | cfg |  | [0:0] | true |true |
  pub struct Config {
    reg: zermio::Register<u32>,
  }

  impl Config {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: 
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn cfg(&mut self) -> CfgField {
        CfgField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type CfgField<'a> = zermio::BitField<'a, 0, 1, u32, zermio::access::ReadWrite>;
}



/// .  
pub use self::test_reg::*;
mod test_reg {

  use super::*;

  /// # TEST_REG fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | tr |  | [0:0] | true |true |
  pub struct TestReg {
    reg: zermio::Register<u32>,
  }

  impl TestReg {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: 
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tr(&mut self) -> TrField {
        TrField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type TrField<'a> = zermio::BitField<'a, 0, 1, u32, zermio::access::ReadWrite>;
}
