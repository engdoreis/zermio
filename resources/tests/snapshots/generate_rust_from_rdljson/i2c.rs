
/*
 * File autogenerated by the test.
 */

//zermio


//! These are the registers present in the i2c 
//! | Register name      | Description  | Offset | Write | Read| 
//! | :---               | :---         | :---   | :--   | :-- |
//! | INTR_STATE | Interrupt State Register | 0x0 | true |true |
//! | INTR_ENABLE | Interrupt Enable Register | 0x4 | true |true |
//! | INTR_TEST | Interrupt Test Register | 0x8 | true |false |
//! | CTRL | I2C Control Register | 0x10 | true |true |
//! | STATUS | I2C Live Status Register for Host and Target modes | 0x14 | false |true |
//! | RDATA | I2C Read Data | 0x18 | false |true |
//! | FDATA | I2C Host Format DataWrites to this register are used to define and drive Controller-Mode transactions. | 0x1c | true |false |
//! | FIFO_CTRL | I2C FIFO control register | 0x20 | true |false |
//! | HOST_FIFO_CONFIG | Host mode FIFO configuration | 0x24 | true |true |
//! | TARGET_FIFO_CONFIG | Target mode FIFO configuration | 0x28 | true |true |
//! | HOST_FIFO_STATUS | Host mode FIFO status register | 0x2c | false |true |
//! | TARGET_FIFO_STATUS | Target mode FIFO status register | 0x30 | false |true |
//! | OVRD | I2C Override Control Register | 0x34 | true |true |
//! | VAL | Oversampled RX values | 0x38 | false |true |
//! | TIMING0 | Detailed I2C Timings (directly corresponding to table 10 in the I2C Specification).All values are expressed in units of the input clock period.These must be greater than 2 in order for the change in SCL to propagate to the input of the FSM so that acknowledgements are detected correctly. | 0x3c | true |true |
//! | TIMING1 | Detailed I2C Timings (directly corresponding to table 10 in the I2C Specification).All values are expressed in units of the input clock period. | 0x40 | true |true |
//! | TIMING2 | Detailed I2C Timings (directly corresponding to table 10 in the I2C Specification).All values are expressed in units of the input clock period. | 0x44 | true |true |
//! | TIMING3 | Detailed I2C Timings (directly corresponding to table 10, in the I2C Specification).All values are expressed in units of the input clock period. | 0x48 | true |true |
//! | TIMING4 | Detailed I2C Timings (directly corresponding to table 10, in the I2C Specification).All values are expressed in units of the input clock period. | 0x4c | true |true |
//! | TIMEOUT_CTRL | I2C clock stretching and bus timeout control.This timeout must be enabled by setting !!TIMEOUT_CTRL.EN to 1, and the behavior of this feature depends on the value of !!TIMEOUT_CTRL.MODE.If the mode is "STRETCH_TIMEOUT", this is used in I2C controller mode to detect whether a connected target is stretching a single low time beyond the timeout value.Configured as such, this timeout is more informative and doesn't do more than assert the "stretch_timeout" interrupt.If the mode is "BUS_TIMEOUT", it is used to detect whether the clock has been held low for too long instead, inclusive of the controller's clock low time.This is useful for an SMBus context, where the VAL programmed should be tTIMEOUT:MIN. | 0x50 | true |true |
//! | TARGET_ID | I2C target address and mask pairs | 0x54 | true |true |
//! | ACQDATA | I2C target acquired data | 0x58 | false |true |
//! | TXDATA | I2C target transmit data | 0x5c | true |false |
//! | HOST_TIMEOUT_CTRL | I2C host clock generation timeout value (in units of input clock frequency).In an active transaction in Target-Mode, if the Controller ceases to send SCL pulsesfor this number of cycles then the "host_timeout" interrupt will be asserted.In multi-controller monitoring mode, !!HOST_TIMEOUT_CTRL is required to be nonzero to transition out of the initial busy state.Set this CSR to 0 to disable this behaviour. | 0x60 | true |true |
//! | TARGET_TIMEOUT_CTRL | I2C target internal stretching timeout control.When the target has stretched beyond this time it will send a NACK for incoming data bytes or release SDA for outgoing data bytes.The behavior for the address byte is configurable via !!CTRL.ACK_ADDR_AFTER_TIMEOUT.Note that the count accumulates stretching time over the course of a transaction.In other words, this is equivalent to the SMBus cumulative target clock extension time. | 0x64 | true |true |
//! | TARGET_NACK_COUNT | Number of times the I2C target has NACK'ed a new transaction since the last read of this register.Reading this register clears it.This is useful because when the ACQ FIFO is full the software know that a NACK has occurred, but without this register would not know how many transactions it missed.When it reaches its maximum value it will stay at that value. | 0x68 | true |true |
//! | TARGET_ACK_CTRL | Controls for mid-transfer (N)ACK phase handling | 0x6c | true |true |
//! | ACQ_FIFO_NEXT_DATA | The data byte pending to be written to the ACQ FIFO.This CSR is only valid while the Target module is stretching in the (N)ACK phase, indicated by !!STATUS.ACK_CTRL_STRETCH .It is intended to be used with ACK Control Mode, so software may check the current byte. | 0x70 | false |true |
//! | HOST_NACK_HANDLER_TIMEOUT | Timeout in Host-Mode for an unhandled NACK before hardware automatically ends the transaction.(in units of input clock frequency)If an active Controller-Transmitter transfer receives a NACK from the Target, the !!CONTROLLER_EVENTS.NACK bit is set.In turn, this causes the Controller FSM to halt awaiting software intervention, and the 'controller_halt' interrupt may assert.Software must clear the !!CONTROLLER_EVENTS.NACK bit to allow the state machine to continue, typically after clearing out the FMTFIFO to start a new transfer.While halted, the active transaction is not ended (no STOP (P) condition is created), and the block asserts SCL and leaves SDA released.This timeout can be used to automatically produce a STOP condition, whether as a backstop for slow software responses (longer timeout) or as a convenience (short timeout).If the timeout expires, the Controller FSM will issue a STOP (P) condition on the bus to end the active transaction.Additionally, the !!CONTROLLER_EVENTS.UNHANDLED_NACK_TIMEOUT bit is set to alert software, and the FSM will return to the idle state and halt until the bit is cleared.The enable bit must be set for this feature to operate. | 0x74 | true |true |
//! | CONTROLLER_EVENTS | Latched events that explain why the controller halted.Any bits that are set must be written (with a 1) to clear the CONTROLLER_HALT interrupt. | 0x78 | true |true |
//! | TARGET_EVENTS | Latched events that can cause the target module to stretch the clock at the beginning of a read transfer.These events cause TX FIFO-related stretching even when the TX FIFO has data available.Any bits that are set must be written (with a 1) to clear the tx_stretch interrupt.This CSR serves as a gate to prevent the Target module from responding to a read command with unrelated, leftover data. | 0x7c | true |true |

use super::zermio;
/// ``` rust
/// i2c.intr_state.update(|intr_state| {
///     if intr_state.fmt_threshold().read() == 1 {
///        intr_state.fmt_threshold().write(0);
///     }
/// });
/// ```
pub struct I2c {
    /// Interrupt State Register  
    pub intr_state : intr_state::IntrState,
    /// Interrupt Enable Register  
    pub intr_enable : intr_enable::IntrEnable,
    /// Interrupt Test Register  
    pub intr_test : intr_test::IntrTest,
    /// I2C Control Register  
    pub ctrl : ctrl::Ctrl,
    /// I2C Live Status Register for Host and Target modes  
    pub status : status::Status,
    /// I2C Read Data  
    pub rdata : rdata::Rdata,
    /// I2C Host Format DataWrites to this register are used to define and drive Controller-Mode transactions.  
    pub fdata : fdata::Fdata,
    /// I2C FIFO control register  
    pub fifo_ctrl : fifo_ctrl::FifoCtrl,
    /// Host mode FIFO configuration  
    pub host_fifo_config : host_fifo_config::HostFifoConfig,
    /// Target mode FIFO configuration  
    pub target_fifo_config : target_fifo_config::TargetFifoConfig,
    /// Host mode FIFO status register  
    pub host_fifo_status : host_fifo_status::HostFifoStatus,
    /// Target mode FIFO status register  
    pub target_fifo_status : target_fifo_status::TargetFifoStatus,
    /// I2C Override Control Register  
    pub ovrd : ovrd::Ovrd,
    /// Oversampled RX values  
    pub val : val::Val,
    /// Detailed I2C Timings (directly corresponding to table 10 in the I2C Specification).All values are expressed in units of the input clock period.These must be greater than 2 in order for the change in SCL to propagate to the input of the FSM so that acknowledgements are detected correctly.  
    pub timing0 : timing0::Timing0,
    /// Detailed I2C Timings (directly corresponding to table 10 in the I2C Specification).All values are expressed in units of the input clock period.  
    pub timing1 : timing1::Timing1,
    /// Detailed I2C Timings (directly corresponding to table 10 in the I2C Specification).All values are expressed in units of the input clock period.  
    pub timing2 : timing2::Timing2,
    /// Detailed I2C Timings (directly corresponding to table 10, in the I2C Specification).All values are expressed in units of the input clock period.  
    pub timing3 : timing3::Timing3,
    /// Detailed I2C Timings (directly corresponding to table 10, in the I2C Specification).All values are expressed in units of the input clock period.  
    pub timing4 : timing4::Timing4,
    /// I2C clock stretching and bus timeout control.This timeout must be enabled by setting !!TIMEOUT_CTRL.EN to 1, and the behavior of this feature depends on the value of !!TIMEOUT_CTRL.MODE.If the mode is "STRETCH_TIMEOUT", this is used in I2C controller mode to detect whether a connected target is stretching a single low time beyond the timeout value.Configured as such, this timeout is more informative and doesn't do more than assert the "stretch_timeout" interrupt.If the mode is "BUS_TIMEOUT", it is used to detect whether the clock has been held low for too long instead, inclusive of the controller's clock low time.This is useful for an SMBus context, where the VAL programmed should be tTIMEOUT:MIN.  
    pub timeout_ctrl : timeout_ctrl::TimeoutCtrl,
    /// I2C target address and mask pairs  
    pub target_id : target_id::TargetId,
    /// I2C target acquired data  
    pub acqdata : acqdata::Acqdata,
    /// I2C target transmit data  
    pub txdata : txdata::Txdata,
    /// I2C host clock generation timeout value (in units of input clock frequency).In an active transaction in Target-Mode, if the Controller ceases to send SCL pulsesfor this number of cycles then the "host_timeout" interrupt will be asserted.In multi-controller monitoring mode, !!HOST_TIMEOUT_CTRL is required to be nonzero to transition out of the initial busy state.Set this CSR to 0 to disable this behaviour.  
    pub host_timeout_ctrl : host_timeout_ctrl::HostTimeoutCtrl,
    /// I2C target internal stretching timeout control.When the target has stretched beyond this time it will send a NACK for incoming data bytes or release SDA for outgoing data bytes.The behavior for the address byte is configurable via !!CTRL.ACK_ADDR_AFTER_TIMEOUT.Note that the count accumulates stretching time over the course of a transaction.In other words, this is equivalent to the SMBus cumulative target clock extension time.  
    pub target_timeout_ctrl : target_timeout_ctrl::TargetTimeoutCtrl,
    /// Number of times the I2C target has NACK'ed a new transaction since the last read of this register.Reading this register clears it.This is useful because when the ACQ FIFO is full the software know that a NACK has occurred, but without this register would not know how many transactions it missed.When it reaches its maximum value it will stay at that value.  
    pub target_nack_count : target_nack_count::TargetNackCount,
    /// Controls for mid-transfer (N)ACK phase handling  
    pub target_ack_ctrl : target_ack_ctrl::TargetAckCtrl,
    /// The data byte pending to be written to the ACQ FIFO.This CSR is only valid while the Target module is stretching in the (N)ACK phase, indicated by !!STATUS.ACK_CTRL_STRETCH .It is intended to be used with ACK Control Mode, so software may check the current byte.  
    pub acq_fifo_next_data : acq_fifo_next_data::AcqFifoNextData,
    /// Timeout in Host-Mode for an unhandled NACK before hardware automatically ends the transaction.(in units of input clock frequency)If an active Controller-Transmitter transfer receives a NACK from the Target, the !!CONTROLLER_EVENTS.NACK bit is set.In turn, this causes the Controller FSM to halt awaiting software intervention, and the 'controller_halt' interrupt may assert.Software must clear the !!CONTROLLER_EVENTS.NACK bit to allow the state machine to continue, typically after clearing out the FMTFIFO to start a new transfer.While halted, the active transaction is not ended (no STOP (P) condition is created), and the block asserts SCL and leaves SDA released.This timeout can be used to automatically produce a STOP condition, whether as a backstop for slow software responses (longer timeout) or as a convenience (short timeout).If the timeout expires, the Controller FSM will issue a STOP (P) condition on the bus to end the active transaction.Additionally, the !!CONTROLLER_EVENTS.UNHANDLED_NACK_TIMEOUT bit is set to alert software, and the FSM will return to the idle state and halt until the bit is cleared.The enable bit must be set for this feature to operate.  
    pub host_nack_handler_timeout : host_nack_handler_timeout::HostNackHandlerTimeout,
    /// Latched events that explain why the controller halted.Any bits that are set must be written (with a 1) to clear the CONTROLLER_HALT interrupt.  
    pub controller_events : controller_events::ControllerEvents,
    /// Latched events that can cause the target module to stretch the clock at the beginning of a read transfer.These events cause TX FIFO-related stretching even when the TX FIFO has data available.Any bits that are set must be written (with a 1) to clear the tx_stretch interrupt.This CSR serves as a gate to prevent the Target module from responding to a read command with unrelated, leftover data.  
    pub target_events : target_events::TargetEvents,
}

impl I2c {
    pub fn new(instance: u32) -> Self {
    let addr = instance as u32;
      Self {
        intr_state : intr_state::IntrState::new(addr + 0x0 ),
        intr_enable : intr_enable::IntrEnable::new(addr + 0x4 ),
        intr_test : intr_test::IntrTest::new(addr + 0x8 ),
        ctrl : ctrl::Ctrl::new(addr + 0x10 ),
        status : status::Status::new(addr + 0x14 ),
        rdata : rdata::Rdata::new(addr + 0x18 ),
        fdata : fdata::Fdata::new(addr + 0x1c ),
        fifo_ctrl : fifo_ctrl::FifoCtrl::new(addr + 0x20 ),
        host_fifo_config : host_fifo_config::HostFifoConfig::new(addr + 0x24 ),
        target_fifo_config : target_fifo_config::TargetFifoConfig::new(addr + 0x28 ),
        host_fifo_status : host_fifo_status::HostFifoStatus::new(addr + 0x2c ),
        target_fifo_status : target_fifo_status::TargetFifoStatus::new(addr + 0x30 ),
        ovrd : ovrd::Ovrd::new(addr + 0x34 ),
        val : val::Val::new(addr + 0x38 ),
        timing0 : timing0::Timing0::new(addr + 0x3c ),
        timing1 : timing1::Timing1::new(addr + 0x40 ),
        timing2 : timing2::Timing2::new(addr + 0x44 ),
        timing3 : timing3::Timing3::new(addr + 0x48 ),
        timing4 : timing4::Timing4::new(addr + 0x4c ),
        timeout_ctrl : timeout_ctrl::TimeoutCtrl::new(addr + 0x50 ),
        target_id : target_id::TargetId::new(addr + 0x54 ),
        acqdata : acqdata::Acqdata::new(addr + 0x58 ),
        txdata : txdata::Txdata::new(addr + 0x5c ),
        host_timeout_ctrl : host_timeout_ctrl::HostTimeoutCtrl::new(addr + 0x60 ),
        target_timeout_ctrl : target_timeout_ctrl::TargetTimeoutCtrl::new(addr + 0x64 ),
        target_nack_count : target_nack_count::TargetNackCount::new(addr + 0x68 ),
        target_ack_ctrl : target_ack_ctrl::TargetAckCtrl::new(addr + 0x6c ),
        acq_fifo_next_data : acq_fifo_next_data::AcqFifoNextData::new(addr + 0x70 ),
        host_nack_handler_timeout : host_nack_handler_timeout::HostNackHandlerTimeout::new(addr + 0x74 ),
        controller_events : controller_events::ControllerEvents::new(addr + 0x78 ),
        target_events : target_events::TargetEvents::new(addr + 0x7c ),
      }
  }
}



/// Interrupt State Register.  
pub use self::intr_state::*;
mod intr_state {

  use super::*;

  /// # INTR_STATE fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | FMT_THRESHOLD | host mode interrupt: asserted whilst the FMT FIFO level is below the low threshold. This is a level status interrupt. | [0:0] | false |true |
  /// | RX_THRESHOLD | host mode interrupt: asserted whilst the RX FIFO level is above the high threshold. This is a level status interrupt. | [1:1] | false |true |
  /// | ACQ_THRESHOLD | target mode interrupt: asserted whilst the ACQ FIFO level is above the high threshold. This is a level status interrupt. | [2:2] | false |true |
  /// | RX_OVERFLOW | host mode interrupt: raised if the RX FIFO has overflowed. | [3:3] | true |true |
  /// | CONTROLLER_HALT | host mode interrupt: raised if the controller FSM is halted, such as on an unexpected NACK or lost arbitration.Check !!CONTROLLER_EVENTS for the reason.The interrupt will be released when the bits in !!CONTROLLER_EVENTS are cleared. | [4:4] | false |true |
  /// | SCL_INTERFERENCE | host mode interrupt: raised if the SCL line drops early (not supported without clock synchronization). | [5:5] | true |true |
  /// | SDA_INTERFERENCE | host mode interrupt: raised if the SDA line goes low when host is trying to assert high | [6:6] | true |true |
  /// | STRETCH_TIMEOUT | host mode interrupt: raised if target stretches the clock beyond the allowed timeout period | [7:7] | true |true |
  /// | SDA_UNSTABLE | host mode interrupt: raised if the target does not assert a constant value of SDA during transmission. | [8:8] | true |true |
  /// | CMD_COMPLETE | host and target mode interrupt.In host mode, raised if the host issues a repeated START or terminates the transaction by issuing STOP.In target mode, raised if the external host issues a STOP or repeated START. | [9:9] | true |true |
  /// | TX_STRETCH | target mode interrupt: raised if the target is stretching clocks for a read command. This is a level status interrupt. | [10:10] | false |true |
  /// | TX_THRESHOLD | target mode interrupt: asserted whilst the TX FIFO level is below the low threshold. This is a level status interrupt. | [11:11] | false |true |
  /// | ACQ_STRETCH | target mode interrupt: raised if the target is stretching clocks due to full ACQ FIFO or zero count in !!TARGET_ACK_CTRL.NBYTES (if enabled). This is a level status interrupt. | [12:12] | false |true |
  /// | UNEXP_STOP | target mode interrupt: raised if STOP is received without a preceding NACK during an external host read. | [13:13] | true |true |
  /// | HOST_TIMEOUT | target mode interrupt: raised if the host stops sending the clock during an ongoing transaction. | [14:14] | true |true |
  pub struct IntrState {
    reg: zermio::Register<u32>,
  }

  impl IntrState {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: host mode interrupt: asserted whilst the FMT FIFO level is below the low threshold. This is a level status interrupt.
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn fmt_threshold(&mut self) -> FmtThresholdField {
        FmtThresholdField::new(&mut self.reg)
    }

  /// Hardware description: host mode interrupt: asserted whilst the RX FIFO level is above the high threshold. This is a level status interrupt.
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_threshold(&mut self) -> RxThresholdField {
        RxThresholdField::new(&mut self.reg)
    }

  /// Hardware description: target mode interrupt: asserted whilst the ACQ FIFO level is above the high threshold. This is a level status interrupt.
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn acq_threshold(&mut self) -> AcqThresholdField {
        AcqThresholdField::new(&mut self.reg)
    }

  /// Hardware description: host mode interrupt: raised if the RX FIFO has overflowed.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_overflow(&mut self) -> RxOverflowField {
        RxOverflowField::new(&mut self.reg)
    }

  /// Hardware description: host mode interrupt: raised if the controller FSM is halted, such as on an unexpected NACK or lost arbitration.Check !!CONTROLLER_EVENTS for the reason.The interrupt will be released when the bits in !!CONTROLLER_EVENTS are cleared.
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn controller_halt(&mut self) -> ControllerHaltField {
        ControllerHaltField::new(&mut self.reg)
    }

  /// Hardware description: host mode interrupt: raised if the SCL line drops early (not supported without clock synchronization).
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn scl_interference(&mut self) -> SclInterferenceField {
        SclInterferenceField::new(&mut self.reg)
    }

  /// Hardware description: host mode interrupt: raised if the SDA line goes low when host is trying to assert high
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn sda_interference(&mut self) -> SdaInterferenceField {
        SdaInterferenceField::new(&mut self.reg)
    }

  /// Hardware description: host mode interrupt: raised if target stretches the clock beyond the allowed timeout period
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn stretch_timeout(&mut self) -> StretchTimeoutField {
        StretchTimeoutField::new(&mut self.reg)
    }

  /// Hardware description: host mode interrupt: raised if the target does not assert a constant value of SDA during transmission.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn sda_unstable(&mut self) -> SdaUnstableField {
        SdaUnstableField::new(&mut self.reg)
    }

  /// Hardware description: host and target mode interrupt.In host mode, raised if the host issues a repeated START or terminates the transaction by issuing STOP.In target mode, raised if the external host issues a STOP or repeated START.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn cmd_complete(&mut self) -> CmdCompleteField {
        CmdCompleteField::new(&mut self.reg)
    }

  /// Hardware description: target mode interrupt: raised if the target is stretching clocks for a read command. This is a level status interrupt.
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tx_stretch(&mut self) -> TxStretchField {
        TxStretchField::new(&mut self.reg)
    }

  /// Hardware description: target mode interrupt: asserted whilst the TX FIFO level is below the low threshold. This is a level status interrupt.
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tx_threshold(&mut self) -> TxThresholdField {
        TxThresholdField::new(&mut self.reg)
    }

  /// Hardware description: target mode interrupt: raised if the target is stretching clocks due to full ACQ FIFO or zero count in !!TARGET_ACK_CTRL.NBYTES (if enabled). This is a level status interrupt.
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn acq_stretch(&mut self) -> AcqStretchField {
        AcqStretchField::new(&mut self.reg)
    }

  /// Hardware description: target mode interrupt: raised if STOP is received without a preceding NACK during an external host read.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn unexp_stop(&mut self) -> UnexpStopField {
        UnexpStopField::new(&mut self.reg)
    }

  /// Hardware description: target mode interrupt: raised if the host stops sending the clock during an ongoing transaction.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn host_timeout(&mut self) -> HostTimeoutField {
        HostTimeoutField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type FmtThresholdField<'a> = zermio::BitField<'a, 0, 1, u32, zermio::access::Read>;
  type RxThresholdField<'a> = zermio::BitField<'a, 1, 1, u32, zermio::access::Read>;
  type AcqThresholdField<'a> = zermio::BitField<'a, 2, 1, u32, zermio::access::Read>;
  type RxOverflowField<'a> = zermio::BitField<'a, 3, 1, u32, zermio::access::ReadWrite>;
  type ControllerHaltField<'a> = zermio::BitField<'a, 4, 1, u32, zermio::access::Read>;
  type SclInterferenceField<'a> = zermio::BitField<'a, 5, 1, u32, zermio::access::ReadWrite>;
  type SdaInterferenceField<'a> = zermio::BitField<'a, 6, 1, u32, zermio::access::ReadWrite>;
  type StretchTimeoutField<'a> = zermio::BitField<'a, 7, 1, u32, zermio::access::ReadWrite>;
  type SdaUnstableField<'a> = zermio::BitField<'a, 8, 1, u32, zermio::access::ReadWrite>;
  type CmdCompleteField<'a> = zermio::BitField<'a, 9, 1, u32, zermio::access::ReadWrite>;
  type TxStretchField<'a> = zermio::BitField<'a, 10, 1, u32, zermio::access::Read>;
  type TxThresholdField<'a> = zermio::BitField<'a, 11, 1, u32, zermio::access::Read>;
  type AcqStretchField<'a> = zermio::BitField<'a, 12, 1, u32, zermio::access::Read>;
  type UnexpStopField<'a> = zermio::BitField<'a, 13, 1, u32, zermio::access::ReadWrite>;
  type HostTimeoutField<'a> = zermio::BitField<'a, 14, 1, u32, zermio::access::ReadWrite>;
}



/// Interrupt Enable Register.  
pub use self::intr_enable::*;
mod intr_enable {

  use super::*;

  /// # INTR_ENABLE fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | FMT_THRESHOLD | Enable interrupt when !!INTR_STATE.fmt_threshold is set. | [0:0] | true |true |
  /// | RX_THRESHOLD | Enable interrupt when !!INTR_STATE.rx_threshold is set. | [1:1] | true |true |
  /// | ACQ_THRESHOLD | Enable interrupt when !!INTR_STATE.acq_threshold is set. | [2:2] | true |true |
  /// | RX_OVERFLOW | Enable interrupt when !!INTR_STATE.rx_overflow is set. | [3:3] | true |true |
  /// | CONTROLLER_HALT | Enable interrupt when !!INTR_STATE.controller_halt is set. | [4:4] | true |true |
  /// | SCL_INTERFERENCE | Enable interrupt when !!INTR_STATE.scl_interference is set. | [5:5] | true |true |
  /// | SDA_INTERFERENCE | Enable interrupt when !!INTR_STATE.sda_interference is set. | [6:6] | true |true |
  /// | STRETCH_TIMEOUT | Enable interrupt when !!INTR_STATE.stretch_timeout is set. | [7:7] | true |true |
  /// | SDA_UNSTABLE | Enable interrupt when !!INTR_STATE.sda_unstable is set. | [8:8] | true |true |
  /// | CMD_COMPLETE | Enable interrupt when !!INTR_STATE.cmd_complete is set. | [9:9] | true |true |
  /// | TX_STRETCH | Enable interrupt when !!INTR_STATE.tx_stretch is set. | [10:10] | true |true |
  /// | TX_THRESHOLD | Enable interrupt when !!INTR_STATE.tx_threshold is set. | [11:11] | true |true |
  /// | ACQ_STRETCH | Enable interrupt when !!INTR_STATE.acq_stretch is set. | [12:12] | true |true |
  /// | UNEXP_STOP | Enable interrupt when !!INTR_STATE.unexp_stop is set. | [13:13] | true |true |
  /// | HOST_TIMEOUT | Enable interrupt when !!INTR_STATE.host_timeout is set. | [14:14] | true |true |
  pub struct IntrEnable {
    reg: zermio::Register<u32>,
  }

  impl IntrEnable {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Enable interrupt when !!INTR_STATE.fmt_threshold is set.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn fmt_threshold(&mut self) -> FmtThresholdField {
        FmtThresholdField::new(&mut self.reg)
    }

  /// Hardware description: Enable interrupt when !!INTR_STATE.rx_threshold is set.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_threshold(&mut self) -> RxThresholdField {
        RxThresholdField::new(&mut self.reg)
    }

  /// Hardware description: Enable interrupt when !!INTR_STATE.acq_threshold is set.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn acq_threshold(&mut self) -> AcqThresholdField {
        AcqThresholdField::new(&mut self.reg)
    }

  /// Hardware description: Enable interrupt when !!INTR_STATE.rx_overflow is set.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_overflow(&mut self) -> RxOverflowField {
        RxOverflowField::new(&mut self.reg)
    }

  /// Hardware description: Enable interrupt when !!INTR_STATE.controller_halt is set.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn controller_halt(&mut self) -> ControllerHaltField {
        ControllerHaltField::new(&mut self.reg)
    }

  /// Hardware description: Enable interrupt when !!INTR_STATE.scl_interference is set.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn scl_interference(&mut self) -> SclInterferenceField {
        SclInterferenceField::new(&mut self.reg)
    }

  /// Hardware description: Enable interrupt when !!INTR_STATE.sda_interference is set.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn sda_interference(&mut self) -> SdaInterferenceField {
        SdaInterferenceField::new(&mut self.reg)
    }

  /// Hardware description: Enable interrupt when !!INTR_STATE.stretch_timeout is set.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn stretch_timeout(&mut self) -> StretchTimeoutField {
        StretchTimeoutField::new(&mut self.reg)
    }

  /// Hardware description: Enable interrupt when !!INTR_STATE.sda_unstable is set.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn sda_unstable(&mut self) -> SdaUnstableField {
        SdaUnstableField::new(&mut self.reg)
    }

  /// Hardware description: Enable interrupt when !!INTR_STATE.cmd_complete is set.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn cmd_complete(&mut self) -> CmdCompleteField {
        CmdCompleteField::new(&mut self.reg)
    }

  /// Hardware description: Enable interrupt when !!INTR_STATE.tx_stretch is set.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tx_stretch(&mut self) -> TxStretchField {
        TxStretchField::new(&mut self.reg)
    }

  /// Hardware description: Enable interrupt when !!INTR_STATE.tx_threshold is set.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tx_threshold(&mut self) -> TxThresholdField {
        TxThresholdField::new(&mut self.reg)
    }

  /// Hardware description: Enable interrupt when !!INTR_STATE.acq_stretch is set.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn acq_stretch(&mut self) -> AcqStretchField {
        AcqStretchField::new(&mut self.reg)
    }

  /// Hardware description: Enable interrupt when !!INTR_STATE.unexp_stop is set.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn unexp_stop(&mut self) -> UnexpStopField {
        UnexpStopField::new(&mut self.reg)
    }

  /// Hardware description: Enable interrupt when !!INTR_STATE.host_timeout is set.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn host_timeout(&mut self) -> HostTimeoutField {
        HostTimeoutField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type FmtThresholdField<'a> = zermio::BitField<'a, 0, 1, u32, zermio::access::ReadWrite>;
  type RxThresholdField<'a> = zermio::BitField<'a, 1, 1, u32, zermio::access::ReadWrite>;
  type AcqThresholdField<'a> = zermio::BitField<'a, 2, 1, u32, zermio::access::ReadWrite>;
  type RxOverflowField<'a> = zermio::BitField<'a, 3, 1, u32, zermio::access::ReadWrite>;
  type ControllerHaltField<'a> = zermio::BitField<'a, 4, 1, u32, zermio::access::ReadWrite>;
  type SclInterferenceField<'a> = zermio::BitField<'a, 5, 1, u32, zermio::access::ReadWrite>;
  type SdaInterferenceField<'a> = zermio::BitField<'a, 6, 1, u32, zermio::access::ReadWrite>;
  type StretchTimeoutField<'a> = zermio::BitField<'a, 7, 1, u32, zermio::access::ReadWrite>;
  type SdaUnstableField<'a> = zermio::BitField<'a, 8, 1, u32, zermio::access::ReadWrite>;
  type CmdCompleteField<'a> = zermio::BitField<'a, 9, 1, u32, zermio::access::ReadWrite>;
  type TxStretchField<'a> = zermio::BitField<'a, 10, 1, u32, zermio::access::ReadWrite>;
  type TxThresholdField<'a> = zermio::BitField<'a, 11, 1, u32, zermio::access::ReadWrite>;
  type AcqStretchField<'a> = zermio::BitField<'a, 12, 1, u32, zermio::access::ReadWrite>;
  type UnexpStopField<'a> = zermio::BitField<'a, 13, 1, u32, zermio::access::ReadWrite>;
  type HostTimeoutField<'a> = zermio::BitField<'a, 14, 1, u32, zermio::access::ReadWrite>;
}



/// Interrupt Test Register.  
pub use self::intr_test::*;
mod intr_test {

  use super::*;

  /// # INTR_TEST fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | FMT_THRESHOLD | Write 1 to force !!INTR_STATE.fmt_threshold to 1. | [0:0] | true |false |
  /// | RX_THRESHOLD | Write 1 to force !!INTR_STATE.rx_threshold to 1. | [1:1] | true |false |
  /// | ACQ_THRESHOLD | Write 1 to force !!INTR_STATE.acq_threshold to 1. | [2:2] | true |false |
  /// | RX_OVERFLOW | Write 1 to force !!INTR_STATE.rx_overflow to 1. | [3:3] | true |false |
  /// | CONTROLLER_HALT | Write 1 to force !!INTR_STATE.controller_halt to 1. | [4:4] | true |false |
  /// | SCL_INTERFERENCE | Write 1 to force !!INTR_STATE.scl_interference to 1. | [5:5] | true |false |
  /// | SDA_INTERFERENCE | Write 1 to force !!INTR_STATE.sda_interference to 1. | [6:6] | true |false |
  /// | STRETCH_TIMEOUT | Write 1 to force !!INTR_STATE.stretch_timeout to 1. | [7:7] | true |false |
  /// | SDA_UNSTABLE | Write 1 to force !!INTR_STATE.sda_unstable to 1. | [8:8] | true |false |
  /// | CMD_COMPLETE | Write 1 to force !!INTR_STATE.cmd_complete to 1. | [9:9] | true |false |
  /// | TX_STRETCH | Write 1 to force !!INTR_STATE.tx_stretch to 1. | [10:10] | true |false |
  /// | TX_THRESHOLD | Write 1 to force !!INTR_STATE.tx_threshold to 1. | [11:11] | true |false |
  /// | ACQ_STRETCH | Write 1 to force !!INTR_STATE.acq_stretch to 1. | [12:12] | true |false |
  /// | UNEXP_STOP | Write 1 to force !!INTR_STATE.unexp_stop to 1. | [13:13] | true |false |
  /// | HOST_TIMEOUT | Write 1 to force !!INTR_STATE.host_timeout to 1. | [14:14] | true |false |
  pub struct IntrTest {
    reg: zermio::Register<u32>,
  }

  impl IntrTest {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Write 1 to force !!INTR_STATE.fmt_threshold to 1.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn fmt_threshold(&mut self) -> FmtThresholdField {
        FmtThresholdField::new(&mut self.reg)
    }

  /// Hardware description: Write 1 to force !!INTR_STATE.rx_threshold to 1.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_threshold(&mut self) -> RxThresholdField {
        RxThresholdField::new(&mut self.reg)
    }

  /// Hardware description: Write 1 to force !!INTR_STATE.acq_threshold to 1.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn acq_threshold(&mut self) -> AcqThresholdField {
        AcqThresholdField::new(&mut self.reg)
    }

  /// Hardware description: Write 1 to force !!INTR_STATE.rx_overflow to 1.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_overflow(&mut self) -> RxOverflowField {
        RxOverflowField::new(&mut self.reg)
    }

  /// Hardware description: Write 1 to force !!INTR_STATE.controller_halt to 1.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn controller_halt(&mut self) -> ControllerHaltField {
        ControllerHaltField::new(&mut self.reg)
    }

  /// Hardware description: Write 1 to force !!INTR_STATE.scl_interference to 1.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn scl_interference(&mut self) -> SclInterferenceField {
        SclInterferenceField::new(&mut self.reg)
    }

  /// Hardware description: Write 1 to force !!INTR_STATE.sda_interference to 1.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn sda_interference(&mut self) -> SdaInterferenceField {
        SdaInterferenceField::new(&mut self.reg)
    }

  /// Hardware description: Write 1 to force !!INTR_STATE.stretch_timeout to 1.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn stretch_timeout(&mut self) -> StretchTimeoutField {
        StretchTimeoutField::new(&mut self.reg)
    }

  /// Hardware description: Write 1 to force !!INTR_STATE.sda_unstable to 1.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn sda_unstable(&mut self) -> SdaUnstableField {
        SdaUnstableField::new(&mut self.reg)
    }

  /// Hardware description: Write 1 to force !!INTR_STATE.cmd_complete to 1.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn cmd_complete(&mut self) -> CmdCompleteField {
        CmdCompleteField::new(&mut self.reg)
    }

  /// Hardware description: Write 1 to force !!INTR_STATE.tx_stretch to 1.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tx_stretch(&mut self) -> TxStretchField {
        TxStretchField::new(&mut self.reg)
    }

  /// Hardware description: Write 1 to force !!INTR_STATE.tx_threshold to 1.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tx_threshold(&mut self) -> TxThresholdField {
        TxThresholdField::new(&mut self.reg)
    }

  /// Hardware description: Write 1 to force !!INTR_STATE.acq_stretch to 1.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn acq_stretch(&mut self) -> AcqStretchField {
        AcqStretchField::new(&mut self.reg)
    }

  /// Hardware description: Write 1 to force !!INTR_STATE.unexp_stop to 1.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn unexp_stop(&mut self) -> UnexpStopField {
        UnexpStopField::new(&mut self.reg)
    }

  /// Hardware description: Write 1 to force !!INTR_STATE.host_timeout to 1.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn host_timeout(&mut self) -> HostTimeoutField {
        HostTimeoutField::new(&mut self.reg)
    }

    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
  }
  type FmtThresholdField<'a> = zermio::BitField<'a, 0, 1, u32, zermio::access::Write>;
  type RxThresholdField<'a> = zermio::BitField<'a, 1, 1, u32, zermio::access::Write>;
  type AcqThresholdField<'a> = zermio::BitField<'a, 2, 1, u32, zermio::access::Write>;
  type RxOverflowField<'a> = zermio::BitField<'a, 3, 1, u32, zermio::access::Write>;
  type ControllerHaltField<'a> = zermio::BitField<'a, 4, 1, u32, zermio::access::Write>;
  type SclInterferenceField<'a> = zermio::BitField<'a, 5, 1, u32, zermio::access::Write>;
  type SdaInterferenceField<'a> = zermio::BitField<'a, 6, 1, u32, zermio::access::Write>;
  type StretchTimeoutField<'a> = zermio::BitField<'a, 7, 1, u32, zermio::access::Write>;
  type SdaUnstableField<'a> = zermio::BitField<'a, 8, 1, u32, zermio::access::Write>;
  type CmdCompleteField<'a> = zermio::BitField<'a, 9, 1, u32, zermio::access::Write>;
  type TxStretchField<'a> = zermio::BitField<'a, 10, 1, u32, zermio::access::Write>;
  type TxThresholdField<'a> = zermio::BitField<'a, 11, 1, u32, zermio::access::Write>;
  type AcqStretchField<'a> = zermio::BitField<'a, 12, 1, u32, zermio::access::Write>;
  type UnexpStopField<'a> = zermio::BitField<'a, 13, 1, u32, zermio::access::Write>;
  type HostTimeoutField<'a> = zermio::BitField<'a, 14, 1, u32, zermio::access::Write>;
}



/// I2C Control Register.  
pub use self::ctrl::*;
mod ctrl {

  use super::*;

  /// # CTRL fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | ENABLEHOST | Enable Host I2C functionality | [0:0] | true |true |
  /// | ENABLETARGET | Enable Target I2C functionality | [1:1] | true |true |
  /// | LLPBK | Enable I2C line loopback testIf line loopback is enabled, the internal design sees ACQ and RX data as "1" | [2:2] | true |true |
  /// | NACK_ADDR_AFTER_TIMEOUT | Enable NACKing the address on a stretch timeout.This is a Target mode feature.If enabled (1), a stretch timeout will cause the device to NACK the address byte.If disabled (0), a stretch timeout will cause the device to ACK the address byte.SMBus requires that devices always ACK their address, even for read commands.However, non-SMBus protocols may have a different approach and can choose to NACK instead.Note that both cases handle data bytes the same way.For writes, the Target module will NACK all subsequent data bytes until it receives a Stop.For reads, the Target module will release SDA, causing 0xff to be returned for all data bytes until it receives a Stop. | [3:3] | true |true |
  /// | ACK_CTRL_EN | Enable I2C Target ACK Control Mode.ACK Control Mode works together with !!TARGET_ACK_CTRL.NBYTES to allow software to control upper-layer protocol (N)ACKing (e.g. as in SMBus).This bit enables the mode when 1, and !!TARGET_ACK_CTRL.NBYTES limits how many bytes may be automatically ACK'd while the ACQ FIFO has space.If it is 0, the decision to ACK or NACK is made only from stretching timeouts and !!CTRL.NACK_ADDR_AFTER_TIMEOUT. | [4:4] | true |true |
  /// | MULTI_CONTROLLER_MONITOR_EN | Enable the bus monitor in multi-controller mode.If a 0->1 transition happens while !!CTRL.ENABLEHOST and !!CTRL.ENABLETARGET are both 0, the bus monitor will enable and begin in the "bus busy" state.To transition to a bus free state, !!HOST_TIMEOUT_CTRL must be nonzero, so the bus monitor may count out idle cycles to confirm the freedom to transmit.In addition, the bus monitor will track whether the bus is free based on the enabled timeouts and detected Stop symbols.For multi-controller mode, ensure !!CTRL.MULTI_CONTROLLER_MONITOR_EN becomes 1 no later than !!CTRL.ENABLEHOST or !!CTRL.ENABLETARGET.This bit can be set at the same time as either or both of the other two, though.Note that if !!CTRL.MULTI_CONTROLLER_MONITOR_EN is set after !!CTRL.ENABLEHOST or !!CTRL.ENABLETARGET, the bus monitor will begin in the "bus free" state instead.This would violate the proper protocol for a controller to join a multi-controller environment.However, if this controller is known to be the first to join, this ordering will enable skipping the idle wait.When 0, the bus monitor will report that the bus is always free, so the controller FSM is never blocked from transmitting. | [5:5] | true |true |
  /// | TX_STRETCH_CTRL_EN | If set to 1, this bit causes a read transfer addressed to this target to set the corresponding bit in !!TARGET_EVENTS.While !!TARGET_EVENTS.TX_PENDING is 1, subsequent read transactions will stretch the clock, even if there is data in the TX FIFO.If enabled, this function allows software to confirm the data in the TX FIFO should be released for the current read.This may be useful for cases where the TX FIFO has data that does not apply to the current transfer.For example, the transaction could've targeted an alternate function via another address. | [6:6] | true |true |
  pub struct Ctrl {
    reg: zermio::Register<u32>,
  }

  impl Ctrl {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Enable Host I2C functionality
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn enablehost(&mut self) -> EnablehostField {
        EnablehostField::new(&mut self.reg)
    }

  /// Hardware description: Enable Target I2C functionality
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn enabletarget(&mut self) -> EnabletargetField {
        EnabletargetField::new(&mut self.reg)
    }

  /// Hardware description: Enable I2C line loopback testIf line loopback is enabled, the internal design sees ACQ and RX data as "1"
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn llpbk(&mut self) -> LlpbkField {
        LlpbkField::new(&mut self.reg)
    }

  /// Hardware description: Enable NACKing the address on a stretch timeout.This is a Target mode feature.If enabled (1), a stretch timeout will cause the device to NACK the address byte.If disabled (0), a stretch timeout will cause the device to ACK the address byte.SMBus requires that devices always ACK their address, even for read commands.However, non-SMBus protocols may have a different approach and can choose to NACK instead.Note that both cases handle data bytes the same way.For writes, the Target module will NACK all subsequent data bytes until it receives a Stop.For reads, the Target module will release SDA, causing 0xff to be returned for all data bytes until it receives a Stop.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn nack_addr_after_timeout(&mut self) -> NackAddrAfterTimeoutField {
        NackAddrAfterTimeoutField::new(&mut self.reg)
    }

  /// Hardware description: Enable I2C Target ACK Control Mode.ACK Control Mode works together with !!TARGET_ACK_CTRL.NBYTES to allow software to control upper-layer protocol (N)ACKing (e.g. as in SMBus).This bit enables the mode when 1, and !!TARGET_ACK_CTRL.NBYTES limits how many bytes may be automatically ACK'd while the ACQ FIFO has space.If it is 0, the decision to ACK or NACK is made only from stretching timeouts and !!CTRL.NACK_ADDR_AFTER_TIMEOUT.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn ack_ctrl_en(&mut self) -> AckCtrlEnField {
        AckCtrlEnField::new(&mut self.reg)
    }

  /// Hardware description: Enable the bus monitor in multi-controller mode.If a 0->1 transition happens while !!CTRL.ENABLEHOST and !!CTRL.ENABLETARGET are both 0, the bus monitor will enable and begin in the "bus busy" state.To transition to a bus free state, !!HOST_TIMEOUT_CTRL must be nonzero, so the bus monitor may count out idle cycles to confirm the freedom to transmit.In addition, the bus monitor will track whether the bus is free based on the enabled timeouts and detected Stop symbols.For multi-controller mode, ensure !!CTRL.MULTI_CONTROLLER_MONITOR_EN becomes 1 no later than !!CTRL.ENABLEHOST or !!CTRL.ENABLETARGET.This bit can be set at the same time as either or both of the other two, though.Note that if !!CTRL.MULTI_CONTROLLER_MONITOR_EN is set after !!CTRL.ENABLEHOST or !!CTRL.ENABLETARGET, the bus monitor will begin in the "bus free" state instead.This would violate the proper protocol for a controller to join a multi-controller environment.However, if this controller is known to be the first to join, this ordering will enable skipping the idle wait.When 0, the bus monitor will report that the bus is always free, so the controller FSM is never blocked from transmitting.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn multi_controller_monitor_en(&mut self) -> MultiControllerMonitorEnField {
        MultiControllerMonitorEnField::new(&mut self.reg)
    }

  /// Hardware description: If set to 1, this bit causes a read transfer addressed to this target to set the corresponding bit in !!TARGET_EVENTS.While !!TARGET_EVENTS.TX_PENDING is 1, subsequent read transactions will stretch the clock, even if there is data in the TX FIFO.If enabled, this function allows software to confirm the data in the TX FIFO should be released for the current read.This may be useful for cases where the TX FIFO has data that does not apply to the current transfer.For example, the transaction could've targeted an alternate function via another address.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tx_stretch_ctrl_en(&mut self) -> TxStretchCtrlEnField {
        TxStretchCtrlEnField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type EnablehostField<'a> = zermio::BitField<'a, 0, 1, u32, zermio::access::ReadWrite>;
  type EnabletargetField<'a> = zermio::BitField<'a, 1, 1, u32, zermio::access::ReadWrite>;
  type LlpbkField<'a> = zermio::BitField<'a, 2, 1, u32, zermio::access::ReadWrite>;
  type NackAddrAfterTimeoutField<'a> = zermio::BitField<'a, 3, 1, u32, zermio::access::ReadWrite>;
  type AckCtrlEnField<'a> = zermio::BitField<'a, 4, 1, u32, zermio::access::ReadWrite>;
  type MultiControllerMonitorEnField<'a> = zermio::BitField<'a, 5, 1, u32, zermio::access::ReadWrite>;
  type TxStretchCtrlEnField<'a> = zermio::BitField<'a, 6, 1, u32, zermio::access::ReadWrite>;
}



/// I2C Live Status Register for Host and Target modes.  
pub use self::status::*;
mod status {

  use super::*;

  /// # STATUS fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | FMTFULL | Host mode FMT FIFO is full | [0:0] | false |true |
  /// | RXFULL | Host mode RX FIFO is full | [1:1] | false |true |
  /// | FMTEMPTY | Host mode FMT FIFO is empty | [2:2] | false |true |
  /// | HOSTIDLE | Host functionality is idle. No Host transaction is in progress | [3:3] | false |true |
  /// | TARGETIDLE | Target functionality is idle. No Target transaction is in progress | [4:4] | false |true |
  /// | RXEMPTY | Host mode RX FIFO is empty | [5:5] | false |true |
  /// | TXFULL | Target mode TX FIFO is full | [6:6] | false |true |
  /// | ACQFULL | Target mode receive FIFO is full | [7:7] | false |true |
  /// | TXEMPTY | Target mode TX FIFO is empty | [8:8] | false |true |
  /// | ACQEMPTY | Target mode receive FIFO is empty | [9:9] | false |true |
  /// | ACK_CTRL_STRETCH | Target mode stretching at (N)ACK phase due to zero count in !!TARGET_ACK_CTRL.NBYTES | [10:10] | false |true |
  pub struct Status {
    reg: zermio::Register<u32>,
  }

  impl Status {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Host mode FMT FIFO is full
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn fmtfull(&mut self) -> FmtfullField {
        FmtfullField::new(&mut self.reg)
    }

  /// Hardware description: Host mode RX FIFO is full
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rxfull(&mut self) -> RxfullField {
        RxfullField::new(&mut self.reg)
    }

  /// Hardware description: Host mode FMT FIFO is empty
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn fmtempty(&mut self) -> FmtemptyField {
        FmtemptyField::new(&mut self.reg)
    }

  /// Hardware description: Host functionality is idle. No Host transaction is in progress
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn hostidle(&mut self) -> HostidleField {
        HostidleField::new(&mut self.reg)
    }

  /// Hardware description: Target functionality is idle. No Target transaction is in progress
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn targetidle(&mut self) -> TargetidleField {
        TargetidleField::new(&mut self.reg)
    }

  /// Hardware description: Host mode RX FIFO is empty
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rxempty(&mut self) -> RxemptyField {
        RxemptyField::new(&mut self.reg)
    }

  /// Hardware description: Target mode TX FIFO is full
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn txfull(&mut self) -> TxfullField {
        TxfullField::new(&mut self.reg)
    }

  /// Hardware description: Target mode receive FIFO is full
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn acqfull(&mut self) -> AcqfullField {
        AcqfullField::new(&mut self.reg)
    }

  /// Hardware description: Target mode TX FIFO is empty
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn txempty(&mut self) -> TxemptyField {
        TxemptyField::new(&mut self.reg)
    }

  /// Hardware description: Target mode receive FIFO is empty
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn acqempty(&mut self) -> AcqemptyField {
        AcqemptyField::new(&mut self.reg)
    }

  /// Hardware description: Target mode stretching at (N)ACK phase due to zero count in !!TARGET_ACK_CTRL.NBYTES
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn ack_ctrl_stretch(&mut self) -> AckCtrlStretchField {
        AckCtrlStretchField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
  }
  type FmtfullField<'a> = zermio::BitField<'a, 0, 1, u32, zermio::access::Read>;
  type RxfullField<'a> = zermio::BitField<'a, 1, 1, u32, zermio::access::Read>;
  type FmtemptyField<'a> = zermio::BitField<'a, 2, 1, u32, zermio::access::Read>;
  type HostidleField<'a> = zermio::BitField<'a, 3, 1, u32, zermio::access::Read>;
  type TargetidleField<'a> = zermio::BitField<'a, 4, 1, u32, zermio::access::Read>;
  type RxemptyField<'a> = zermio::BitField<'a, 5, 1, u32, zermio::access::Read>;
  type TxfullField<'a> = zermio::BitField<'a, 6, 1, u32, zermio::access::Read>;
  type AcqfullField<'a> = zermio::BitField<'a, 7, 1, u32, zermio::access::Read>;
  type TxemptyField<'a> = zermio::BitField<'a, 8, 1, u32, zermio::access::Read>;
  type AcqemptyField<'a> = zermio::BitField<'a, 9, 1, u32, zermio::access::Read>;
  type AckCtrlStretchField<'a> = zermio::BitField<'a, 10, 1, u32, zermio::access::Read>;
}



/// I2C Read Data.  
pub use self::rdata::*;
mod rdata {

  use super::*;

  /// # RDATA fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | RDATA |  | [7:0] | false |true |
  pub struct Rdata {
    reg: zermio::Register<u32>,
  }

  impl Rdata {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: 
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rdata(&mut self) -> RdataField {
        RdataField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
  }
  type RdataField<'a> = zermio::BitField<'a, 0, 8, u32, zermio::access::Read>;
}



/// I2C Host Format DataWrites to this register are used to define and drive Controller-Mode transactions..  
pub use self::fdata::*;
mod fdata {

  use super::*;

  /// # FDATA fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | FBYTE | Format Byte.If no flags are set, hardware will transmit this byte directly.If READB is set, this field becomes the number of bytes hardware will automaticallyread from the bus. | [7:0] | true |false |
  /// | START | Issue a START condition before transmitting FBYTE. | [8:8] | true |false |
  /// | STOP | Issue a STOP condition after transmitting FBYTE. | [9:9] | true |false |
  /// | READB | Transfer Direction Indicator.If unset, this write to FDATA defines a controller-transmitter operation (WRITE).A single byte of data (FBYTE) is written to the bus.If set, this write to FDATA defines a controller-receiver operation (READ).The value of FBYTE defines the number of bytes read from the bus. (256 if FBYTE==0)"After this number of bytes are read, the final byte will be NACKed to end the transferunless RCONT is also set. | [10:10] | true |false |
  /// | RCONT | Do not NACK the last byte read, let the read operation continue. | [11:11] | true |false |
  /// | NAKOK | For the currrent controller-transmitter byte (WRITE), do not halt via CONTROLLER_EVENTSor assert the 'controller_halt' interrupt if the current byte is not ACK'd. | [12:12] | true |false |
  pub struct Fdata {
    reg: zermio::Register<u32>,
  }

  impl Fdata {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Format Byte.If no flags are set, hardware will transmit this byte directly.If READB is set, this field becomes the number of bytes hardware will automaticallyread from the bus.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn fbyte(&mut self) -> FbyteField {
        FbyteField::new(&mut self.reg)
    }

  /// Hardware description: Issue a START condition before transmitting FBYTE.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn start(&mut self) -> StartField {
        StartField::new(&mut self.reg)
    }

  /// Hardware description: Issue a STOP condition after transmitting FBYTE.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn stop(&mut self) -> StopField {
        StopField::new(&mut self.reg)
    }

  /// Hardware description: Transfer Direction Indicator.If unset, this write to FDATA defines a controller-transmitter operation (WRITE).A single byte of data (FBYTE) is written to the bus.If set, this write to FDATA defines a controller-receiver operation (READ).The value of FBYTE defines the number of bytes read from the bus. (256 if FBYTE==0)"After this number of bytes are read, the final byte will be NACKed to end the transferunless RCONT is also set.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn readb(&mut self) -> ReadbField {
        ReadbField::new(&mut self.reg)
    }

  /// Hardware description: Do not NACK the last byte read, let the read operation continue.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rcont(&mut self) -> RcontField {
        RcontField::new(&mut self.reg)
    }

  /// Hardware description: For the currrent controller-transmitter byte (WRITE), do not halt via CONTROLLER_EVENTSor assert the 'controller_halt' interrupt if the current byte is not ACK'd.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn nakok(&mut self) -> NakokField {
        NakokField::new(&mut self.reg)
    }

    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
  }
  type FbyteField<'a> = zermio::BitField<'a, 0, 8, u32, zermio::access::Write>;
  type StartField<'a> = zermio::BitField<'a, 8, 1, u32, zermio::access::Write>;
  type StopField<'a> = zermio::BitField<'a, 9, 1, u32, zermio::access::Write>;
  type ReadbField<'a> = zermio::BitField<'a, 10, 1, u32, zermio::access::Write>;
  type RcontField<'a> = zermio::BitField<'a, 11, 1, u32, zermio::access::Write>;
  type NakokField<'a> = zermio::BitField<'a, 12, 1, u32, zermio::access::Write>;
}



/// I2C FIFO control register.  
pub use self::fifo_ctrl::*;
mod fifo_ctrl {

  use super::*;

  /// # FIFO_CTRL fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | RXRST | RX fifo reset. Write 1 to the register resets RX_FIFO. Read returns 0 | [0:0] | true |false |
  /// | FMTRST | FMT fifo reset. Write 1 to the register resets FMT_FIFO. Read returns 0 | [1:1] | true |false |
  /// | ACQRST | ACQ FIFO reset. Write 1 to the register resets it. Read returns 0 | [7:7] | true |false |
  /// | TXRST | TX FIFO reset. Write 1 to the register resets it. Read returns 0 | [8:8] | true |false |
  pub struct FifoCtrl {
    reg: zermio::Register<u32>,
  }

  impl FifoCtrl {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: RX fifo reset. Write 1 to the register resets RX_FIFO. Read returns 0
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rxrst(&mut self) -> RxrstField {
        RxrstField::new(&mut self.reg)
    }

  /// Hardware description: FMT fifo reset. Write 1 to the register resets FMT_FIFO. Read returns 0
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn fmtrst(&mut self) -> FmtrstField {
        FmtrstField::new(&mut self.reg)
    }

  /// Hardware description: ACQ FIFO reset. Write 1 to the register resets it. Read returns 0
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn acqrst(&mut self) -> AcqrstField {
        AcqrstField::new(&mut self.reg)
    }

  /// Hardware description: TX FIFO reset. Write 1 to the register resets it. Read returns 0
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn txrst(&mut self) -> TxrstField {
        TxrstField::new(&mut self.reg)
    }

    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
  }
  type RxrstField<'a> = zermio::BitField<'a, 0, 1, u32, zermio::access::Write>;
  type FmtrstField<'a> = zermio::BitField<'a, 1, 1, u32, zermio::access::Write>;
  type AcqrstField<'a> = zermio::BitField<'a, 7, 1, u32, zermio::access::Write>;
  type TxrstField<'a> = zermio::BitField<'a, 8, 1, u32, zermio::access::Write>;
}



/// Host mode FIFO configuration.  
pub use self::host_fifo_config::*;
mod host_fifo_config {

  use super::*;

  /// # HOST_FIFO_CONFIG fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | RX_THRESH | Threshold level for RX interrupts. Whilst the level of data in the RX FIFOis above this setting, the rx_threshold interrupt will be asserted. | [11:0] | true |true |
  /// | FMT_THRESH | Threshold level for FMT interrupts. Whilst the number of used entries in theFMT FIFO is below this setting, the fmt_threshold interrupt will be asserted. | [27:16] | true |true |
  pub struct HostFifoConfig {
    reg: zermio::Register<u32>,
  }

  impl HostFifoConfig {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Threshold level for RX interrupts. Whilst the level of data in the RX FIFOis above this setting, the rx_threshold interrupt will be asserted.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_thresh(&mut self) -> RxThreshField {
        RxThreshField::new(&mut self.reg)
    }

  /// Hardware description: Threshold level for FMT interrupts. Whilst the number of used entries in theFMT FIFO is below this setting, the fmt_threshold interrupt will be asserted.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn fmt_thresh(&mut self) -> FmtThreshField {
        FmtThreshField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type RxThreshField<'a> = zermio::BitField<'a, 0, 12, u32, zermio::access::ReadWrite>;
  type FmtThreshField<'a> = zermio::BitField<'a, 16, 12, u32, zermio::access::ReadWrite>;
}



/// Target mode FIFO configuration.  
pub use self::target_fifo_config::*;
mod target_fifo_config {

  use super::*;

  /// # TARGET_FIFO_CONFIG fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | TX_THRESH | Threshold level for TX interrupts. Whilst the number of used entries in theTX FIFO is below this setting, the tx_threshold interrupt will be asserted. | [11:0] | true |true |
  /// | ACQ_THRESH | Threshold level for ACQ interrupts. Whilst the level of data in the ACQ FIFOis above this setting, the acq_threshold interrupt will be asserted. | [27:16] | true |true |
  pub struct TargetFifoConfig {
    reg: zermio::Register<u32>,
  }

  impl TargetFifoConfig {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Threshold level for TX interrupts. Whilst the number of used entries in theTX FIFO is below this setting, the tx_threshold interrupt will be asserted.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tx_thresh(&mut self) -> TxThreshField {
        TxThreshField::new(&mut self.reg)
    }

  /// Hardware description: Threshold level for ACQ interrupts. Whilst the level of data in the ACQ FIFOis above this setting, the acq_threshold interrupt will be asserted.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn acq_thresh(&mut self) -> AcqThreshField {
        AcqThreshField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type TxThreshField<'a> = zermio::BitField<'a, 0, 12, u32, zermio::access::ReadWrite>;
  type AcqThreshField<'a> = zermio::BitField<'a, 16, 12, u32, zermio::access::ReadWrite>;
}



/// Host mode FIFO status register.  
pub use self::host_fifo_status::*;
mod host_fifo_status {

  use super::*;

  /// # HOST_FIFO_STATUS fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | FMTLVL | Current fill level of FMT fifo | [11:0] | false |true |
  /// | RXLVL | Current fill level of RX fifo | [27:16] | false |true |
  pub struct HostFifoStatus {
    reg: zermio::Register<u32>,
  }

  impl HostFifoStatus {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Current fill level of FMT fifo
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn fmtlvl(&mut self) -> FmtlvlField {
        FmtlvlField::new(&mut self.reg)
    }

  /// Hardware description: Current fill level of RX fifo
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rxlvl(&mut self) -> RxlvlField {
        RxlvlField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
  }
  type FmtlvlField<'a> = zermio::BitField<'a, 0, 12, u32, zermio::access::Read>;
  type RxlvlField<'a> = zermio::BitField<'a, 16, 12, u32, zermio::access::Read>;
}



/// Target mode FIFO status register.  
pub use self::target_fifo_status::*;
mod target_fifo_status {

  use super::*;

  /// # TARGET_FIFO_STATUS fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | TXLVL | Current fill level of TX fifo | [11:0] | false |true |
  /// | ACQLVL | Current fill level of ACQ fifo | [27:16] | false |true |
  pub struct TargetFifoStatus {
    reg: zermio::Register<u32>,
  }

  impl TargetFifoStatus {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Current fill level of TX fifo
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn txlvl(&mut self) -> TxlvlField {
        TxlvlField::new(&mut self.reg)
    }

  /// Hardware description: Current fill level of ACQ fifo
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn acqlvl(&mut self) -> AcqlvlField {
        AcqlvlField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
  }
  type TxlvlField<'a> = zermio::BitField<'a, 0, 12, u32, zermio::access::Read>;
  type AcqlvlField<'a> = zermio::BitField<'a, 16, 12, u32, zermio::access::Read>;
}



/// I2C Override Control Register.  
pub use self::ovrd::*;
mod ovrd {

  use super::*;

  /// # OVRD fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | TXOVRDEN | Override the SDA and SCL TX signals. | [0:0] | true |true |
  /// | SCLVAL | Value for SCL Override. Set to 0 to drive TX Low, and set to 1 for high-Z | [1:1] | true |true |
  /// | SDAVAL | Value for SDA Override. Set to 0 to drive TX Low, and set to 1 for high-Z | [2:2] | true |true |
  pub struct Ovrd {
    reg: zermio::Register<u32>,
  }

  impl Ovrd {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Override the SDA and SCL TX signals.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn txovrden(&mut self) -> TxovrdenField {
        TxovrdenField::new(&mut self.reg)
    }

  /// Hardware description: Value for SCL Override. Set to 0 to drive TX Low, and set to 1 for high-Z
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn sclval(&mut self) -> SclvalField {
        SclvalField::new(&mut self.reg)
    }

  /// Hardware description: Value for SDA Override. Set to 0 to drive TX Low, and set to 1 for high-Z
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn sdaval(&mut self) -> SdavalField {
        SdavalField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type TxovrdenField<'a> = zermio::BitField<'a, 0, 1, u32, zermio::access::ReadWrite>;
  type SclvalField<'a> = zermio::BitField<'a, 1, 1, u32, zermio::access::ReadWrite>;
  type SdavalField<'a> = zermio::BitField<'a, 2, 1, u32, zermio::access::ReadWrite>;
}



/// Oversampled RX values.  
pub use self::val::*;
mod val {

  use super::*;

  /// # VAL fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | SCL_RX | Last 16 oversampled values of SCL. Most recent bit is bit 0, oldest 15. | [15:0] | false |true |
  /// | SDA_RX | Last 16 oversampled values of SDA. Most recent bit is bit 16, oldest 31. | [31:16] | false |true |
  pub struct Val {
    reg: zermio::Register<u32>,
  }

  impl Val {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Last 16 oversampled values of SCL. Most recent bit is bit 0, oldest 15.
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn scl_rx(&mut self) -> SclRxField {
        SclRxField::new(&mut self.reg)
    }

  /// Hardware description: Last 16 oversampled values of SDA. Most recent bit is bit 16, oldest 31.
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn sda_rx(&mut self) -> SdaRxField {
        SdaRxField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
  }
  type SclRxField<'a> = zermio::BitField<'a, 0, 16, u32, zermio::access::Read>;
  type SdaRxField<'a> = zermio::BitField<'a, 16, 16, u32, zermio::access::Read>;
}



/// Detailed I2C Timings (directly corresponding to table 10 in the I2C Specification).All values are expressed in units of the input clock period.These must be greater than 2 in order for the change in SCL to propagate to the input of the FSM so that acknowledgements are detected correctly..  
pub use self::timing0::*;
mod timing0 {

  use super::*;

  /// # TIMING0 fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | THIGH | The actual time to hold SCL high in a given pulse.This field is sized to have a range of at least Standard Mode's 4.0 us max with a core clock at 1 GHz. | [12:0] | true |true |
  /// | TLOW | The actual time to hold SCL low between any two SCL pulses.This field is sized to have a range of at least Standard Mode's 4.7 us max with a core clock at 1 GHz. | [28:16] | true |true |
  pub struct Timing0 {
    reg: zermio::Register<u32>,
  }

  impl Timing0 {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: The actual time to hold SCL high in a given pulse.This field is sized to have a range of at least Standard Mode's 4.0 us max with a core clock at 1 GHz.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn thigh(&mut self) -> ThighField {
        ThighField::new(&mut self.reg)
    }

  /// Hardware description: The actual time to hold SCL low between any two SCL pulses.This field is sized to have a range of at least Standard Mode's 4.7 us max with a core clock at 1 GHz.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tlow(&mut self) -> TlowField {
        TlowField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type ThighField<'a> = zermio::BitField<'a, 0, 13, u32, zermio::access::ReadWrite>;
  type TlowField<'a> = zermio::BitField<'a, 16, 13, u32, zermio::access::ReadWrite>;
}



/// Detailed I2C Timings (directly corresponding to table 10 in the I2C Specification).All values are expressed in units of the input clock period..  
pub use self::timing1::*;
mod timing1 {

  use super::*;

  /// # TIMING1 fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | T_R | The nominal rise time to anticipate for the bus (depends on capacitance).This field is sized to have a range of at least Standard Mode's 1000 ns max with a core clock at 1 GHz. | [9:0] | true |true |
  /// | T_F | The nominal fall time to anticipate for the bus (influences SDA hold times).This field is sized to have a range of at least Standard Mode's 300 ns max with a core clock at 1 GHz. | [24:16] | true |true |
  pub struct Timing1 {
    reg: zermio::Register<u32>,
  }

  impl Timing1 {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: The nominal rise time to anticipate for the bus (depends on capacitance).This field is sized to have a range of at least Standard Mode's 1000 ns max with a core clock at 1 GHz.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn t_r(&mut self) -> TRField {
        TRField::new(&mut self.reg)
    }

  /// Hardware description: The nominal fall time to anticipate for the bus (influences SDA hold times).This field is sized to have a range of at least Standard Mode's 300 ns max with a core clock at 1 GHz.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn t_f(&mut self) -> TFField {
        TFField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type TRField<'a> = zermio::BitField<'a, 0, 10, u32, zermio::access::ReadWrite>;
  type TFField<'a> = zermio::BitField<'a, 16, 9, u32, zermio::access::ReadWrite>;
}



/// Detailed I2C Timings (directly corresponding to table 10 in the I2C Specification).All values are expressed in units of the input clock period..  
pub use self::timing2::*;
mod timing2 {

  use super::*;

  /// # TIMING2 fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | TSU_STA | Actual setup time for repeated start signals.This field is sized to have a range of at least Standard Mode's 4.7 us max with a core clock at 1 GHz. | [12:0] | true |true |
  /// | THD_STA | Actual hold time for start signals.This field is sized to have a range of at least Standard Mode's 4.0 us max with a core clock at 1 GHz. | [28:16] | true |true |
  pub struct Timing2 {
    reg: zermio::Register<u32>,
  }

  impl Timing2 {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Actual setup time for repeated start signals.This field is sized to have a range of at least Standard Mode's 4.7 us max with a core clock at 1 GHz.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tsu_sta(&mut self) -> TsuStaField {
        TsuStaField::new(&mut self.reg)
    }

  /// Hardware description: Actual hold time for start signals.This field is sized to have a range of at least Standard Mode's 4.0 us max with a core clock at 1 GHz.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn thd_sta(&mut self) -> ThdStaField {
        ThdStaField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type TsuStaField<'a> = zermio::BitField<'a, 0, 13, u32, zermio::access::ReadWrite>;
  type ThdStaField<'a> = zermio::BitField<'a, 16, 13, u32, zermio::access::ReadWrite>;
}



/// Detailed I2C Timings (directly corresponding to table 10, in the I2C Specification).All values are expressed in units of the input clock period..  
pub use self::timing3::*;
mod timing3 {

  use super::*;

  /// # TIMING3 fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | TSU_DAT | Actual setup time for data (or ack) bits.This field is sized to have a range of at least Standard Mode's 250 ns max with a core clock at 1 GHz. | [8:0] | true |true |
  /// | THD_DAT | Actual hold time for data (or ack) bits.(Note, where required, the parameters TVD_DAT is taken to be THD_DAT+T_F)This field is sized to have a range that accommodates Standard Mode's 3.45 us max for TVD_DAT with a core clock at 1 GHz.However, this field is generally expected to represent a time substantially shorter than that.It should be long enough to cover the maximum round-trip latency from output pins, through pads and voltage transitions on the board, and back to the input pins, but it should not be substantially greater. | [28:16] | true |true |
  pub struct Timing3 {
    reg: zermio::Register<u32>,
  }

  impl Timing3 {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Actual setup time for data (or ack) bits.This field is sized to have a range of at least Standard Mode's 250 ns max with a core clock at 1 GHz.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tsu_dat(&mut self) -> TsuDatField {
        TsuDatField::new(&mut self.reg)
    }

  /// Hardware description: Actual hold time for data (or ack) bits.(Note, where required, the parameters TVD_DAT is taken to be THD_DAT+T_F)This field is sized to have a range that accommodates Standard Mode's 3.45 us max for TVD_DAT with a core clock at 1 GHz.However, this field is generally expected to represent a time substantially shorter than that.It should be long enough to cover the maximum round-trip latency from output pins, through pads and voltage transitions on the board, and back to the input pins, but it should not be substantially greater.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn thd_dat(&mut self) -> ThdDatField {
        ThdDatField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type TsuDatField<'a> = zermio::BitField<'a, 0, 9, u32, zermio::access::ReadWrite>;
  type ThdDatField<'a> = zermio::BitField<'a, 16, 13, u32, zermio::access::ReadWrite>;
}



/// Detailed I2C Timings (directly corresponding to table 10, in the I2C Specification).All values are expressed in units of the input clock period..  
pub use self::timing4::*;
mod timing4 {

  use super::*;

  /// # TIMING4 fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | TSU_STO | Actual setup time for stop signals.This field is sized to have a range of at least Standard Mode's 4.0 us max with a core clock at 1 GHz. | [12:0] | true |true |
  /// | T_BUF | Actual time between each STOP signal and the following START signal.This field is sized to have a range of at least Standard Mode's 4.7 us max with a core clock at 1 GHz. | [28:16] | true |true |
  pub struct Timing4 {
    reg: zermio::Register<u32>,
  }

  impl Timing4 {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Actual setup time for stop signals.This field is sized to have a range of at least Standard Mode's 4.0 us max with a core clock at 1 GHz.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tsu_sto(&mut self) -> TsuStoField {
        TsuStoField::new(&mut self.reg)
    }

  /// Hardware description: Actual time between each STOP signal and the following START signal.This field is sized to have a range of at least Standard Mode's 4.7 us max with a core clock at 1 GHz.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn t_buf(&mut self) -> TBufField {
        TBufField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type TsuStoField<'a> = zermio::BitField<'a, 0, 13, u32, zermio::access::ReadWrite>;
  type TBufField<'a> = zermio::BitField<'a, 16, 13, u32, zermio::access::ReadWrite>;
}



/// I2C clock stretching and bus timeout control.This timeout must be enabled by setting !!TIMEOUT_CTRL.EN to 1, and the behavior of this feature depends on the value of !!TIMEOUT_CTRL.MODE.If the mode is "STRETCH_TIMEOUT", this is used in I2C controller mode to detect whether a connected target is stretching a single low time beyond the timeout value.Configured as such, this timeout is more informative and doesn't do more than assert the "stretch_timeout" interrupt.If the mode is "BUS_TIMEOUT", it is used to detect whether the clock has been held low for too long instead, inclusive of the controller's clock low time.This is useful for an SMBus context, where the VAL programmed should be tTIMEOUT:MIN..  
pub use self::timeout_ctrl::*;
mod timeout_ctrl {

  use super::*;

  /// # TIMEOUT_CTRL fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | VAL | Clock stretching timeout value (in units of input clock frequency) | [29:0] | true |true |
  /// | MODE | Selects the timeout mode, between a stretch timeout and a bus timeout.Between the two modes, the primary difference is how much of the clock low period is counted.For a stretch timeout, only the time that another device holds the clock low will be counted.For a bus timeout, the entire clock low time is counted, consistent with the SMBus tTIMEOUT type.!!TIMEOUT_CTRL.EN must be 1 for either of these features to be enabled. | [30:30] | true |true |
  /// | EN | Enable stretch timeout or bus timeout feature | [31:31] | true |true |
  pub struct TimeoutCtrl {
    reg: zermio::Register<u32>,
  }

  impl TimeoutCtrl {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Clock stretching timeout value (in units of input clock frequency)
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn val(&mut self) -> ValField {
        ValField::new(&mut self.reg)
    }

  /// Hardware description: Selects the timeout mode, between a stretch timeout and a bus timeout.Between the two modes, the primary difference is how much of the clock low period is counted.For a stretch timeout, only the time that another device holds the clock low will be counted.For a bus timeout, the entire clock low time is counted, consistent with the SMBus tTIMEOUT type.!!TIMEOUT_CTRL.EN must be 1 for either of these features to be enabled.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn mode(&mut self) -> ModeField {
        ModeField::new(&mut self.reg)
    }

  /// Hardware description: Enable stretch timeout or bus timeout feature
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn en(&mut self) -> EnField {
        EnField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type ValField<'a> = zermio::BitField<'a, 0, 30, u32, zermio::access::ReadWrite>;
  type ModeField<'a> = zermio::BitField<'a, 30, 1, u32, zermio::access::ReadWrite>;
  type EnField<'a> = zermio::BitField<'a, 31, 1, u32, zermio::access::ReadWrite>;
}



/// I2C target address and mask pairs.  
pub use self::target_id::*;
mod target_id {

  use super::*;

  /// # TARGET_ID fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | ADDRESS0 | I2C target address number 0 | [6:0] | true |true |
  /// | MASK0 | I2C target mask number 0.At least one bit in MASK0 must be set to 1 for ADDRESS0 to be used. | [13:7] | true |true |
  /// | ADDRESS1 | I2C target address number 1 | [20:14] | true |true |
  /// | MASK1 | I2C target mask number 1.At least one bit in MASK1 must be set to 1 for ADDRESS1 to be used. | [27:21] | true |true |
  pub struct TargetId {
    reg: zermio::Register<u32>,
  }

  impl TargetId {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: I2C target address number 0
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn address0(&mut self) -> Address0Field {
        Address0Field::new(&mut self.reg)
    }

  /// Hardware description: I2C target mask number 0.At least one bit in MASK0 must be set to 1 for ADDRESS0 to be used.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn mask0(&mut self) -> Mask0Field {
        Mask0Field::new(&mut self.reg)
    }

  /// Hardware description: I2C target address number 1
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn address1(&mut self) -> Address1Field {
        Address1Field::new(&mut self.reg)
    }

  /// Hardware description: I2C target mask number 1.At least one bit in MASK1 must be set to 1 for ADDRESS1 to be used.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn mask1(&mut self) -> Mask1Field {
        Mask1Field::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type Address0Field<'a> = zermio::BitField<'a, 0, 7, u32, zermio::access::ReadWrite>;
  type Mask0Field<'a> = zermio::BitField<'a, 7, 7, u32, zermio::access::ReadWrite>;
  type Address1Field<'a> = zermio::BitField<'a, 14, 7, u32, zermio::access::ReadWrite>;
  type Mask1Field<'a> = zermio::BitField<'a, 21, 7, u32, zermio::access::ReadWrite>;
}



/// I2C target acquired data.  
pub use self::acqdata::*;
mod acqdata {

  use super::*;

  /// # ACQDATA fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | ABYTE | Address for accepted transaction or acquired byte | [7:0] | false |true |
  /// | SIGNAL | Indicates any control symbols associated with the ABYTE.For the STOP symbol, a stretch timeout or other unexpected events will cause a NACK_STOP to appear in the ACQ FIFO.If the ACQ FIFO doesn't have enough space to record a START and a STOP, the transaction will be dropped entirely on a stretch timeout.In that case, the START byte will not appear (neither as START nor NACK_START), but a standalone NACK_STOP may, if there was space.Software can discard any standalone NACK_STOP that appears.See the associated values for more information about the contents. | [10:8] | false |true |
  pub struct Acqdata {
    reg: zermio::Register<u32>,
  }

  impl Acqdata {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Address for accepted transaction or acquired byte
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn abyte(&mut self) -> AbyteField {
        AbyteField::new(&mut self.reg)
    }

  /// Hardware description: Indicates any control symbols associated with the ABYTE.For the STOP symbol, a stretch timeout or other unexpected events will cause a NACK_STOP to appear in the ACQ FIFO.If the ACQ FIFO doesn't have enough space to record a START and a STOP, the transaction will be dropped entirely on a stretch timeout.In that case, the START byte will not appear (neither as START nor NACK_START), but a standalone NACK_STOP may, if there was space.Software can discard any standalone NACK_STOP that appears.See the associated values for more information about the contents.
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn signal(&mut self) -> SignalField {
        SignalField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
  }
  type AbyteField<'a> = zermio::BitField<'a, 0, 8, u32, zermio::access::Read>;
  type SignalField<'a> = zermio::BitField<'a, 8, 3, u32, zermio::access::Read>;
}



/// I2C target transmit data.  
pub use self::txdata::*;
mod txdata {

  use super::*;

  /// # TXDATA fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | TXDATA |  | [7:0] | true |false |
  pub struct Txdata {
    reg: zermio::Register<u32>,
  }

  impl Txdata {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: 
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn txdata(&mut self) -> TxdataField {
        TxdataField::new(&mut self.reg)
    }

    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
  }
  type TxdataField<'a> = zermio::BitField<'a, 0, 8, u32, zermio::access::Write>;
}



/// I2C host clock generation timeout value (in units of input clock frequency).In an active transaction in Target-Mode, if the Controller ceases to send SCL pulsesfor this number of cycles then the "host_timeout" interrupt will be asserted.In multi-controller monitoring mode, !!HOST_TIMEOUT_CTRL is required to be nonzero to transition out of the initial busy state.Set this CSR to 0 to disable this behaviour..  
pub use self::host_timeout_ctrl::*;
mod host_timeout_ctrl {

  use super::*;

  /// # HOST_TIMEOUT_CTRL fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | HOST_TIMEOUT_CTRL |  | [19:0] | true |true |
  pub struct HostTimeoutCtrl {
    reg: zermio::Register<u32>,
  }

  impl HostTimeoutCtrl {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: 
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn host_timeout_ctrl(&mut self) -> HostTimeoutCtrlField {
        HostTimeoutCtrlField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type HostTimeoutCtrlField<'a> = zermio::BitField<'a, 0, 20, u32, zermio::access::ReadWrite>;
}



/// I2C target internal stretching timeout control.When the target has stretched beyond this time it will send a NACK for incoming data bytes or release SDA for outgoing data bytes.The behavior for the address byte is configurable via !!CTRL.ACK_ADDR_AFTER_TIMEOUT.Note that the count accumulates stretching time over the course of a transaction.In other words, this is equivalent to the SMBus cumulative target clock extension time..  
pub use self::target_timeout_ctrl::*;
mod target_timeout_ctrl {

  use super::*;

  /// # TARGET_TIMEOUT_CTRL fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | VAL | Clock stretching timeout value (in units of input clock frequency) | [30:0] | true |true |
  /// | EN | Enable timeout feature and send NACK once the timeout has been reached | [31:31] | true |true |
  pub struct TargetTimeoutCtrl {
    reg: zermio::Register<u32>,
  }

  impl TargetTimeoutCtrl {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Clock stretching timeout value (in units of input clock frequency)
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn val(&mut self) -> ValField {
        ValField::new(&mut self.reg)
    }

  /// Hardware description: Enable timeout feature and send NACK once the timeout has been reached
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn en(&mut self) -> EnField {
        EnField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type ValField<'a> = zermio::BitField<'a, 0, 31, u32, zermio::access::ReadWrite>;
  type EnField<'a> = zermio::BitField<'a, 31, 1, u32, zermio::access::ReadWrite>;
}



/// Number of times the I2C target has NACK'ed a new transaction since the last read of this register.Reading this register clears it.This is useful because when the ACQ FIFO is full the software know that a NACK has occurred, but without this register would not know how many transactions it missed.When it reaches its maximum value it will stay at that value..  
pub use self::target_nack_count::*;
mod target_nack_count {

  use super::*;

  /// # TARGET_NACK_COUNT fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | TARGET_NACK_COUNT |  | [7:0] | true |true |
  pub struct TargetNackCount {
    reg: zermio::Register<u32>,
  }

  impl TargetNackCount {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: 
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn target_nack_count(&mut self) -> TargetNackCountField {
        TargetNackCountField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type TargetNackCountField<'a> = zermio::BitField<'a, 0, 8, u32, zermio::access::ReadWrite>;
}



/// Controls for mid-transfer (N)ACK phase handling.  
pub use self::target_ack_ctrl::*;
mod target_ack_ctrl {

  use super::*;

  /// # TARGET_ACK_CTRL fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | NBYTES | Remaining number of bytes the Target module may ACK automatically.If !!CTRL.ACK_CTRL_EN is set to 1, the Target module will stretch the clock at the (N)ACK phase of a byte if this CSR is 0, awaiting software's instructions.At the beginning of each Write transfer, this byte count is reset to 0.Writes to this CSR also are only accepted while the Target module is stretching the clock.The Target module will always ACK its address if the ACQ FIFO has space.For data bytes afterwards, it will stop at the (N)ACK phase and stretch the clock when this CSR is 0.For each data byte that is ACK'd in a transaction, the byte count will decrease by 1.Note that a full ACQ FIFO can still cause the Target module to halt at the beginning of a new byte.The ACK Control Mode provides an additional synchronization point, during the (N)ACK phase instead of after.For both cases, !!TARGET_TIMEOUT_CTRL applies, and stretching past the timeout will produce an automatic NACK.This mode can be used to implement the mid-transfer (N)ACK responses required by various SMBus protocols. | [8:0] | true |true |
  /// | NACK | When the Target module stretches on the (N)ACK phase of a Write due to !!TARGET_ACK_CTRL.NBYTES being 0, writing a 1 here will cause it to send a NACK.If software chooses to NACK, note that the NACKing behavior is the same as if a stretch timeout occurred.The rest of the transaction will be NACK'd, including subsequent transfers.For the address byte, the (N)ACK phase of subsequent transfers will follow the behavior specified by !!CTRL.NACK_ADDR_AFTER_TIMEOUT.Automatically clears to 0. | [31:31] | true |false |
  pub struct TargetAckCtrl {
    reg: zermio::Register<u32>,
  }

  impl TargetAckCtrl {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Remaining number of bytes the Target module may ACK automatically.If !!CTRL.ACK_CTRL_EN is set to 1, the Target module will stretch the clock at the (N)ACK phase of a byte if this CSR is 0, awaiting software's instructions.At the beginning of each Write transfer, this byte count is reset to 0.Writes to this CSR also are only accepted while the Target module is stretching the clock.The Target module will always ACK its address if the ACQ FIFO has space.For data bytes afterwards, it will stop at the (N)ACK phase and stretch the clock when this CSR is 0.For each data byte that is ACK'd in a transaction, the byte count will decrease by 1.Note that a full ACQ FIFO can still cause the Target module to halt at the beginning of a new byte.The ACK Control Mode provides an additional synchronization point, during the (N)ACK phase instead of after.For both cases, !!TARGET_TIMEOUT_CTRL applies, and stretching past the timeout will produce an automatic NACK.This mode can be used to implement the mid-transfer (N)ACK responses required by various SMBus protocols.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn nbytes(&mut self) -> NbytesField {
        NbytesField::new(&mut self.reg)
    }

  /// Hardware description: When the Target module stretches on the (N)ACK phase of a Write due to !!TARGET_ACK_CTRL.NBYTES being 0, writing a 1 here will cause it to send a NACK.If software chooses to NACK, note that the NACKing behavior is the same as if a stretch timeout occurred.The rest of the transaction will be NACK'd, including subsequent transfers.For the address byte, the (N)ACK phase of subsequent transfers will follow the behavior specified by !!CTRL.NACK_ADDR_AFTER_TIMEOUT.Automatically clears to 0.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn nack(&mut self) -> NackField {
        NackField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type NbytesField<'a> = zermio::BitField<'a, 0, 9, u32, zermio::access::ReadWrite>;
  type NackField<'a> = zermio::BitField<'a, 31, 1, u32, zermio::access::Write>;
}



/// The data byte pending to be written to the ACQ FIFO.This CSR is only valid while the Target module is stretching in the (N)ACK phase, indicated by !!STATUS.ACK_CTRL_STRETCH .It is intended to be used with ACK Control Mode, so software may check the current byte..  
pub use self::acq_fifo_next_data::*;
mod acq_fifo_next_data {

  use super::*;

  /// # ACQ_FIFO_NEXT_DATA fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | ACQ_FIFO_NEXT_DATA |  | [7:0] | false |true |
  pub struct AcqFifoNextData {
    reg: zermio::Register<u32>,
  }

  impl AcqFifoNextData {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: 
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn acq_fifo_next_data(&mut self) -> AcqFifoNextDataField {
        AcqFifoNextDataField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
  }
  type AcqFifoNextDataField<'a> = zermio::BitField<'a, 0, 8, u32, zermio::access::Read>;
}



/// Timeout in Host-Mode for an unhandled NACK before hardware automatically ends the transaction.(in units of input clock frequency)If an active Controller-Transmitter transfer receives a NACK from the Target, the !!CONTROLLER_EVENTS.NACK bit is set.In turn, this causes the Controller FSM to halt awaiting software intervention, and the 'controller_halt' interrupt may assert.Software must clear the !!CONTROLLER_EVENTS.NACK bit to allow the state machine to continue, typically after clearing out the FMTFIFO to start a new transfer.While halted, the active transaction is not ended (no STOP (P) condition is created), and the block asserts SCL and leaves SDA released.This timeout can be used to automatically produce a STOP condition, whether as a backstop for slow software responses (longer timeout) or as a convenience (short timeout).If the timeout expires, the Controller FSM will issue a STOP (P) condition on the bus to end the active transaction.Additionally, the !!CONTROLLER_EVENTS.UNHANDLED_NACK_TIMEOUT bit is set to alert software, and the FSM will return to the idle state and halt until the bit is cleared.The enable bit must be set for this feature to operate..  
pub use self::host_nack_handler_timeout::*;
mod host_nack_handler_timeout {

  use super::*;

  /// # HOST_NACK_HANDLER_TIMEOUT fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | VAL | Unhandled NAK timeout value (in units of input clock frequency) | [30:0] | true |true |
  /// | EN | Timeout enable | [31:31] | true |true |
  pub struct HostNackHandlerTimeout {
    reg: zermio::Register<u32>,
  }

  impl HostNackHandlerTimeout {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Unhandled NAK timeout value (in units of input clock frequency)
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn val(&mut self) -> ValField {
        ValField::new(&mut self.reg)
    }

  /// Hardware description: Timeout enable
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn en(&mut self) -> EnField {
        EnField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type ValField<'a> = zermio::BitField<'a, 0, 31, u32, zermio::access::ReadWrite>;
  type EnField<'a> = zermio::BitField<'a, 31, 1, u32, zermio::access::ReadWrite>;
}



/// Latched events that explain why the controller halted.Any bits that are set must be written (with a 1) to clear the CONTROLLER_HALT interrupt..  
pub use self::controller_events::*;
mod controller_events {

  use super::*;

  /// # CONTROLLER_EVENTS fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | NACK | Received an unexpected NACK | [0:0] | true |true |
  /// | UNHANDLED_NACK_TIMEOUT | A Host-Mode active transaction has been ended by the !!HOST_NACK_HANDLER_TIMEOUT mechanism. | [1:1] | true |true |
  /// | BUS_TIMEOUT | A Host-Mode active transaction has terminated due to a bus timeout activated by !!TIMEOUT_CTRL. | [2:2] | true |true |
  /// | ARBITRATION_LOST | A Host-Mode active transaction has terminated due to lost arbitration. | [3:3] | true |true |
  pub struct ControllerEvents {
    reg: zermio::Register<u32>,
  }

  impl ControllerEvents {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Received an unexpected NACK
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn nack(&mut self) -> NackField {
        NackField::new(&mut self.reg)
    }

  /// Hardware description: A Host-Mode active transaction has been ended by the !!HOST_NACK_HANDLER_TIMEOUT mechanism.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn unhandled_nack_timeout(&mut self) -> UnhandledNackTimeoutField {
        UnhandledNackTimeoutField::new(&mut self.reg)
    }

  /// Hardware description: A Host-Mode active transaction has terminated due to a bus timeout activated by !!TIMEOUT_CTRL.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn bus_timeout(&mut self) -> BusTimeoutField {
        BusTimeoutField::new(&mut self.reg)
    }

  /// Hardware description: A Host-Mode active transaction has terminated due to lost arbitration.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn arbitration_lost(&mut self) -> ArbitrationLostField {
        ArbitrationLostField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type NackField<'a> = zermio::BitField<'a, 0, 1, u32, zermio::access::ReadWrite>;
  type UnhandledNackTimeoutField<'a> = zermio::BitField<'a, 1, 1, u32, zermio::access::ReadWrite>;
  type BusTimeoutField<'a> = zermio::BitField<'a, 2, 1, u32, zermio::access::ReadWrite>;
  type ArbitrationLostField<'a> = zermio::BitField<'a, 3, 1, u32, zermio::access::ReadWrite>;
}



/// Latched events that can cause the target module to stretch the clock at the beginning of a read transfer.These events cause TX FIFO-related stretching even when the TX FIFO has data available.Any bits that are set must be written (with a 1) to clear the tx_stretch interrupt.This CSR serves as a gate to prevent the Target module from responding to a read command with unrelated, leftover data..  
pub use self::target_events::*;
mod target_events {

  use super::*;

  /// # TARGET_EVENTS fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | TX_PENDING | A new Target-Mode read transfer has arrived that addressed this target.This bit is used by software to confirm the release of the contents in the TX FIFO.If the contents do not apply, software should first reset the TX FIFO, then load it with the correct data, then clear this bit.Optionally enabled by !!CTRL.TX_STRETCH_CTRL_EN. | [0:0] | true |true |
  /// | BUS_TIMEOUT | A Target-Mode read transfer has terminated due to a bus timeout activated by !!TIMEOUT_CTRL. | [1:1] | true |true |
  /// | ARBITRATION_LOST | A Target-Mode read transfer has terminated due to lost arbitration. | [2:2] | true |true |
  pub struct TargetEvents {
    reg: zermio::Register<u32>,
  }

  impl TargetEvents {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: A new Target-Mode read transfer has arrived that addressed this target.This bit is used by software to confirm the release of the contents in the TX FIFO.If the contents do not apply, software should first reset the TX FIFO, then load it with the correct data, then clear this bit.Optionally enabled by !!CTRL.TX_STRETCH_CTRL_EN.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tx_pending(&mut self) -> TxPendingField {
        TxPendingField::new(&mut self.reg)
    }

  /// Hardware description: A Target-Mode read transfer has terminated due to a bus timeout activated by !!TIMEOUT_CTRL.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn bus_timeout(&mut self) -> BusTimeoutField {
        BusTimeoutField::new(&mut self.reg)
    }

  /// Hardware description: A Target-Mode read transfer has terminated due to lost arbitration.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn arbitration_lost(&mut self) -> ArbitrationLostField {
        ArbitrationLostField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type TxPendingField<'a> = zermio::BitField<'a, 0, 1, u32, zermio::access::ReadWrite>;
  type BusTimeoutField<'a> = zermio::BitField<'a, 1, 1, u32, zermio::access::ReadWrite>;
  type ArbitrationLostField<'a> = zermio::BitField<'a, 2, 1, u32, zermio::access::ReadWrite>;
}
