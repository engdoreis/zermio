
/*
 * File autogenerated by the test.
 */

//zermio


//! These are the registers present in the uart 
//! | Register name      | Description  | Offset | Write | Read| 
//! | :---               | :---         | :---   | :--   | :-- |
//! | INTR_STATE | Interrupt State Register | 0x0 | true |true |
//! | INTR_ENABLE | Interrupt Enable Register | 0x4 | true |true |
//! | INTR_TEST | Interrupt Test Register | 0x8 | true |false |
//! | CTRL | UART control register | 0x10 | true |true |
//! | STATUS | UART live status register | 0x14 | false |true |
//! | RDATA | UART read data | 0x18 | false |true |
//! | WDATA | UART write data | 0x1c | true |false |
//! | FIFO_CTRL | UART FIFO control register | 0x20 | true |true |
//! | FIFO_STATUS | UART FIFO status register | 0x24 | false |true |
//! | OVRD | TX pin override control. Gives direct SW control over TX pin state | 0x28 | true |true |
//! | VAL | UART oversampled values | 0x2c | false |true |
//! | TIMEOUT_CTRL | UART RX timeout control | 0x30 | true |true |

use super::zermio;
/// ``` rust
/// uart.intr_state.update(|intr_state| {
///     if intr_state.tx_watermark().read() == 1 {
///        intr_state.tx_watermark().write(0);
///     }
/// });
/// ```
pub struct Uart {
    /// Interrupt State Register  
    pub intr_state : intr_state::IntrState,
    /// Interrupt Enable Register  
    pub intr_enable : intr_enable::IntrEnable,
    /// Interrupt Test Register  
    pub intr_test : intr_test::IntrTest,
    /// UART control register  
    pub ctrl : ctrl::Ctrl,
    /// UART live status register  
    pub status : status::Status,
    /// UART read data  
    pub rdata : rdata::Rdata,
    /// UART write data  
    pub wdata : wdata::Wdata,
    /// UART FIFO control register  
    pub fifo_ctrl : fifo_ctrl::FifoCtrl,
    /// UART FIFO status register  
    pub fifo_status : fifo_status::FifoStatus,
    /// TX pin override control. Gives direct SW control over TX pin state  
    pub ovrd : ovrd::Ovrd,
    /// UART oversampled values  
    pub val : val::Val,
    /// UART RX timeout control  
    pub timeout_ctrl : timeout_ctrl::TimeoutCtrl,
}

impl Uart {
    pub fn new(instance: u32) -> Self {
    let addr = instance as u32;
      Self {
        intr_state : intr_state::IntrState::new(addr + 0x0 ),
        intr_enable : intr_enable::IntrEnable::new(addr + 0x4 ),
        intr_test : intr_test::IntrTest::new(addr + 0x8 ),
        ctrl : ctrl::Ctrl::new(addr + 0x10 ),
        status : status::Status::new(addr + 0x14 ),
        rdata : rdata::Rdata::new(addr + 0x18 ),
        wdata : wdata::Wdata::new(addr + 0x1c ),
        fifo_ctrl : fifo_ctrl::FifoCtrl::new(addr + 0x20 ),
        fifo_status : fifo_status::FifoStatus::new(addr + 0x24 ),
        ovrd : ovrd::Ovrd::new(addr + 0x28 ),
        val : val::Val::new(addr + 0x2c ),
        timeout_ctrl : timeout_ctrl::TimeoutCtrl::new(addr + 0x30 ),
      }
  }
}



/// Interrupt State Register.  
pub use self::intr_state::*;
mod intr_state {

  use super::*;

  /// # INTR_STATE fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | TX_WATERMARK | raised if the transmit FIFO is past the high-water mark. | [0:0] | false |true |
  /// | RX_WATERMARK | raised if the receive FIFO is past the high-water mark. | [1:1] | false |true |
  /// | TX_DONE | raised if the transmit FIFO has emptied and no transmit is ongoing. | [2:2] | true |true |
  /// | RX_OVERFLOW | raised if the receive FIFO has overflowed. | [3:3] | true |true |
  /// | RX_FRAME_ERR | raised if a framing error has been detected on receive. | [4:4] | true |true |
  /// | RX_BREAK_ERR | raised if break condition has been detected on receive. | [5:5] | true |true |
  /// | RX_TIMEOUT | raised if RX FIFO has characters remaining in the FIFO without beingretrieved for the programmed time period. | [6:6] | true |true |
  /// | RX_PARITY_ERR | raised if the receiver has detected a parity error. | [7:7] | true |true |
  /// | TX_EMPTY | raised if the transmit FIFO is empty. | [8:8] | false |true |
  pub struct IntrState {
    reg: zermio::Register<u32>,
  }

  impl IntrState {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: raised if the transmit FIFO is past the high-water mark.
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tx_watermark(&mut self) -> TxWatermarkField {
        TxWatermarkField::new(&mut self.reg)
    }

  /// Hardware description: raised if the receive FIFO is past the high-water mark.
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_watermark(&mut self) -> RxWatermarkField {
        RxWatermarkField::new(&mut self.reg)
    }

  /// Hardware description: raised if the transmit FIFO has emptied and no transmit is ongoing.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tx_done(&mut self) -> TxDoneField {
        TxDoneField::new(&mut self.reg)
    }

  /// Hardware description: raised if the receive FIFO has overflowed.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_overflow(&mut self) -> RxOverflowField {
        RxOverflowField::new(&mut self.reg)
    }

  /// Hardware description: raised if a framing error has been detected on receive.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_frame_err(&mut self) -> RxFrameErrField {
        RxFrameErrField::new(&mut self.reg)
    }

  /// Hardware description: raised if break condition has been detected on receive.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_break_err(&mut self) -> RxBreakErrField {
        RxBreakErrField::new(&mut self.reg)
    }

  /// Hardware description: raised if RX FIFO has characters remaining in the FIFO without beingretrieved for the programmed time period.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_timeout(&mut self) -> RxTimeoutField {
        RxTimeoutField::new(&mut self.reg)
    }

  /// Hardware description: raised if the receiver has detected a parity error.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_parity_err(&mut self) -> RxParityErrField {
        RxParityErrField::new(&mut self.reg)
    }

  /// Hardware description: raised if the transmit FIFO is empty.
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tx_empty(&mut self) -> TxEmptyField {
        TxEmptyField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type TxWatermarkField<'a> = zermio::BitField<'a, 0, 1, u32, zermio::access::Read>;
  type RxWatermarkField<'a> = zermio::BitField<'a, 1, 1, u32, zermio::access::Read>;
  type TxDoneField<'a> = zermio::BitField<'a, 2, 1, u32, zermio::access::ReadWrite>;
  type RxOverflowField<'a> = zermio::BitField<'a, 3, 1, u32, zermio::access::ReadWrite>;
  type RxFrameErrField<'a> = zermio::BitField<'a, 4, 1, u32, zermio::access::ReadWrite>;
  type RxBreakErrField<'a> = zermio::BitField<'a, 5, 1, u32, zermio::access::ReadWrite>;
  type RxTimeoutField<'a> = zermio::BitField<'a, 6, 1, u32, zermio::access::ReadWrite>;
  type RxParityErrField<'a> = zermio::BitField<'a, 7, 1, u32, zermio::access::ReadWrite>;
  type TxEmptyField<'a> = zermio::BitField<'a, 8, 1, u32, zermio::access::Read>;
}



/// Interrupt Enable Register.  
pub use self::intr_enable::*;
mod intr_enable {

  use super::*;

  /// # INTR_ENABLE fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | TX_WATERMARK | Enable interrupt when !!INTR_STATE.tx_watermark is set. | [0:0] | true |true |
  /// | RX_WATERMARK | Enable interrupt when !!INTR_STATE.rx_watermark is set. | [1:1] | true |true |
  /// | TX_DONE | Enable interrupt when !!INTR_STATE.tx_done is set. | [2:2] | true |true |
  /// | RX_OVERFLOW | Enable interrupt when !!INTR_STATE.rx_overflow is set. | [3:3] | true |true |
  /// | RX_FRAME_ERR | Enable interrupt when !!INTR_STATE.rx_frame_err is set. | [4:4] | true |true |
  /// | RX_BREAK_ERR | Enable interrupt when !!INTR_STATE.rx_break_err is set. | [5:5] | true |true |
  /// | RX_TIMEOUT | Enable interrupt when !!INTR_STATE.rx_timeout is set. | [6:6] | true |true |
  /// | RX_PARITY_ERR | Enable interrupt when !!INTR_STATE.rx_parity_err is set. | [7:7] | true |true |
  /// | TX_EMPTY | Enable interrupt when !!INTR_STATE.tx_empty is set. | [8:8] | true |true |
  pub struct IntrEnable {
    reg: zermio::Register<u32>,
  }

  impl IntrEnable {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Enable interrupt when !!INTR_STATE.tx_watermark is set.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tx_watermark(&mut self) -> TxWatermarkField {
        TxWatermarkField::new(&mut self.reg)
    }

  /// Hardware description: Enable interrupt when !!INTR_STATE.rx_watermark is set.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_watermark(&mut self) -> RxWatermarkField {
        RxWatermarkField::new(&mut self.reg)
    }

  /// Hardware description: Enable interrupt when !!INTR_STATE.tx_done is set.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tx_done(&mut self) -> TxDoneField {
        TxDoneField::new(&mut self.reg)
    }

  /// Hardware description: Enable interrupt when !!INTR_STATE.rx_overflow is set.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_overflow(&mut self) -> RxOverflowField {
        RxOverflowField::new(&mut self.reg)
    }

  /// Hardware description: Enable interrupt when !!INTR_STATE.rx_frame_err is set.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_frame_err(&mut self) -> RxFrameErrField {
        RxFrameErrField::new(&mut self.reg)
    }

  /// Hardware description: Enable interrupt when !!INTR_STATE.rx_break_err is set.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_break_err(&mut self) -> RxBreakErrField {
        RxBreakErrField::new(&mut self.reg)
    }

  /// Hardware description: Enable interrupt when !!INTR_STATE.rx_timeout is set.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_timeout(&mut self) -> RxTimeoutField {
        RxTimeoutField::new(&mut self.reg)
    }

  /// Hardware description: Enable interrupt when !!INTR_STATE.rx_parity_err is set.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_parity_err(&mut self) -> RxParityErrField {
        RxParityErrField::new(&mut self.reg)
    }

  /// Hardware description: Enable interrupt when !!INTR_STATE.tx_empty is set.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tx_empty(&mut self) -> TxEmptyField {
        TxEmptyField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type TxWatermarkField<'a> = zermio::BitField<'a, 0, 1, u32, zermio::access::ReadWrite>;
  type RxWatermarkField<'a> = zermio::BitField<'a, 1, 1, u32, zermio::access::ReadWrite>;
  type TxDoneField<'a> = zermio::BitField<'a, 2, 1, u32, zermio::access::ReadWrite>;
  type RxOverflowField<'a> = zermio::BitField<'a, 3, 1, u32, zermio::access::ReadWrite>;
  type RxFrameErrField<'a> = zermio::BitField<'a, 4, 1, u32, zermio::access::ReadWrite>;
  type RxBreakErrField<'a> = zermio::BitField<'a, 5, 1, u32, zermio::access::ReadWrite>;
  type RxTimeoutField<'a> = zermio::BitField<'a, 6, 1, u32, zermio::access::ReadWrite>;
  type RxParityErrField<'a> = zermio::BitField<'a, 7, 1, u32, zermio::access::ReadWrite>;
  type TxEmptyField<'a> = zermio::BitField<'a, 8, 1, u32, zermio::access::ReadWrite>;
}



/// Interrupt Test Register.  
pub use self::intr_test::*;
mod intr_test {

  use super::*;

  /// # INTR_TEST fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | TX_WATERMARK | Write 1 to force !!INTR_STATE.tx_watermark to 1. | [0:0] | true |false |
  /// | RX_WATERMARK | Write 1 to force !!INTR_STATE.rx_watermark to 1. | [1:1] | true |false |
  /// | TX_DONE | Write 1 to force !!INTR_STATE.tx_done to 1. | [2:2] | true |false |
  /// | RX_OVERFLOW | Write 1 to force !!INTR_STATE.rx_overflow to 1. | [3:3] | true |false |
  /// | RX_FRAME_ERR | Write 1 to force !!INTR_STATE.rx_frame_err to 1. | [4:4] | true |false |
  /// | RX_BREAK_ERR | Write 1 to force !!INTR_STATE.rx_break_err to 1. | [5:5] | true |false |
  /// | RX_TIMEOUT | Write 1 to force !!INTR_STATE.rx_timeout to 1. | [6:6] | true |false |
  /// | RX_PARITY_ERR | Write 1 to force !!INTR_STATE.rx_parity_err to 1. | [7:7] | true |false |
  /// | TX_EMPTY | Write 1 to force !!INTR_STATE.tx_empty to 1. | [8:8] | true |false |
  pub struct IntrTest {
    reg: zermio::Register<u32>,
  }

  impl IntrTest {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Write 1 to force !!INTR_STATE.tx_watermark to 1.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tx_watermark(&mut self) -> TxWatermarkField {
        TxWatermarkField::new(&mut self.reg)
    }

  /// Hardware description: Write 1 to force !!INTR_STATE.rx_watermark to 1.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_watermark(&mut self) -> RxWatermarkField {
        RxWatermarkField::new(&mut self.reg)
    }

  /// Hardware description: Write 1 to force !!INTR_STATE.tx_done to 1.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tx_done(&mut self) -> TxDoneField {
        TxDoneField::new(&mut self.reg)
    }

  /// Hardware description: Write 1 to force !!INTR_STATE.rx_overflow to 1.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_overflow(&mut self) -> RxOverflowField {
        RxOverflowField::new(&mut self.reg)
    }

  /// Hardware description: Write 1 to force !!INTR_STATE.rx_frame_err to 1.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_frame_err(&mut self) -> RxFrameErrField {
        RxFrameErrField::new(&mut self.reg)
    }

  /// Hardware description: Write 1 to force !!INTR_STATE.rx_break_err to 1.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_break_err(&mut self) -> RxBreakErrField {
        RxBreakErrField::new(&mut self.reg)
    }

  /// Hardware description: Write 1 to force !!INTR_STATE.rx_timeout to 1.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_timeout(&mut self) -> RxTimeoutField {
        RxTimeoutField::new(&mut self.reg)
    }

  /// Hardware description: Write 1 to force !!INTR_STATE.rx_parity_err to 1.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx_parity_err(&mut self) -> RxParityErrField {
        RxParityErrField::new(&mut self.reg)
    }

  /// Hardware description: Write 1 to force !!INTR_STATE.tx_empty to 1.
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tx_empty(&mut self) -> TxEmptyField {
        TxEmptyField::new(&mut self.reg)
    }

    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
  }
  type TxWatermarkField<'a> = zermio::BitField<'a, 0, 1, u32, zermio::access::Write>;
  type RxWatermarkField<'a> = zermio::BitField<'a, 1, 1, u32, zermio::access::Write>;
  type TxDoneField<'a> = zermio::BitField<'a, 2, 1, u32, zermio::access::Write>;
  type RxOverflowField<'a> = zermio::BitField<'a, 3, 1, u32, zermio::access::Write>;
  type RxFrameErrField<'a> = zermio::BitField<'a, 4, 1, u32, zermio::access::Write>;
  type RxBreakErrField<'a> = zermio::BitField<'a, 5, 1, u32, zermio::access::Write>;
  type RxTimeoutField<'a> = zermio::BitField<'a, 6, 1, u32, zermio::access::Write>;
  type RxParityErrField<'a> = zermio::BitField<'a, 7, 1, u32, zermio::access::Write>;
  type TxEmptyField<'a> = zermio::BitField<'a, 8, 1, u32, zermio::access::Write>;
}



/// UART control register.  
pub use self::ctrl::*;
mod ctrl {

  use super::*;

  /// # CTRL fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | TX | TX enable | [0:0] | true |true |
  /// | RX | RX enable | [1:1] | true |true |
  /// | NF | RX noise filter enable.If the noise filter is enabled, RX line goes through the 3-taprepetition code. It ignores single IP clock period noise. | [2:2] | true |true |
  /// | SLPBK | System loopback enable.If this bit is turned on, any outgoing bits to TX are received through RX.See Block Diagram. Note that the TX line goes 1 if System loopback is enabled. | [4:4] | true |true |
  /// | LLPBK | Line loopback enable.If this bit is turned on, incoming bits are forwarded to TX for testing purpose.See Block Diagram. Note that the internal design sees RX value as 1 always if lineloopback is enabled. | [5:5] | true |true |
  /// | PARITY_EN | If true, parity is enabled in both RX and TX directions. | [6:6] | true |true |
  /// | PARITY_ODD | If PARITY_EN is true, this determines the type, 1 for odd parity, 0 for even. | [7:7] | true |true |
  /// | RXBLVL | Trigger level for RX break detection. Sets the number of charactertimes the line must be low to detect a break. | [9:8] | true |true |
  /// | NCO | BAUD clock rate control. | [31:16] | true |true |
  pub struct Ctrl {
    reg: zermio::Register<u32>,
  }

  impl Ctrl {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: TX enable
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn tx(&mut self) -> TxField {
        TxField::new(&mut self.reg)
    }

  /// Hardware description: RX enable
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx(&mut self) -> RxField {
        RxField::new(&mut self.reg)
    }

  /// Hardware description: RX noise filter enable.If the noise filter is enabled, RX line goes through the 3-taprepetition code. It ignores single IP clock period noise.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn nf(&mut self) -> NfField {
        NfField::new(&mut self.reg)
    }

  /// Hardware description: System loopback enable.If this bit is turned on, any outgoing bits to TX are received through RX.See Block Diagram. Note that the TX line goes 1 if System loopback is enabled.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn slpbk(&mut self) -> SlpbkField {
        SlpbkField::new(&mut self.reg)
    }

  /// Hardware description: Line loopback enable.If this bit is turned on, incoming bits are forwarded to TX for testing purpose.See Block Diagram. Note that the internal design sees RX value as 1 always if lineloopback is enabled.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn llpbk(&mut self) -> LlpbkField {
        LlpbkField::new(&mut self.reg)
    }

  /// Hardware description: If true, parity is enabled in both RX and TX directions.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn parity_en(&mut self) -> ParityEnField {
        ParityEnField::new(&mut self.reg)
    }

  /// Hardware description: If PARITY_EN is true, this determines the type, 1 for odd parity, 0 for even.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn parity_odd(&mut self) -> ParityOddField {
        ParityOddField::new(&mut self.reg)
    }

  /// Hardware description: Trigger level for RX break detection. Sets the number of charactertimes the line must be low to detect a break.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rxblvl(&mut self) -> RxblvlField {
        RxblvlField::new(&mut self.reg)
    }

  /// Hardware description: BAUD clock rate control.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn nco(&mut self) -> NcoField {
        NcoField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type TxField<'a> = zermio::BitField<'a, 0, 1, u32, zermio::access::ReadWrite>;
  type RxField<'a> = zermio::BitField<'a, 1, 1, u32, zermio::access::ReadWrite>;
  type NfField<'a> = zermio::BitField<'a, 2, 1, u32, zermio::access::ReadWrite>;
  type SlpbkField<'a> = zermio::BitField<'a, 4, 1, u32, zermio::access::ReadWrite>;
  type LlpbkField<'a> = zermio::BitField<'a, 5, 1, u32, zermio::access::ReadWrite>;
  type ParityEnField<'a> = zermio::BitField<'a, 6, 1, u32, zermio::access::ReadWrite>;
  type ParityOddField<'a> = zermio::BitField<'a, 7, 1, u32, zermio::access::ReadWrite>;
  type RxblvlField<'a> = zermio::BitField<'a, 8, 2, u32, zermio::access::ReadWrite>;
  type NcoField<'a> = zermio::BitField<'a, 16, 16, u32, zermio::access::ReadWrite>;
}



/// UART live status register.  
pub use self::status::*;
mod status {

  use super::*;

  /// # STATUS fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | TXFULL | TX buffer is full | [0:0] | false |true |
  /// | RXFULL | RX buffer is full | [1:1] | false |true |
  /// | TXEMPTY | TX FIFO is empty | [2:2] | false |true |
  /// | TXIDLE | TX FIFO is empty and all bits have been transmitted | [3:3] | false |true |
  /// | RXIDLE | RX is idle | [4:4] | false |true |
  /// | RXEMPTY | RX FIFO is empty | [5:5] | false |true |
  pub struct Status {
    reg: zermio::Register<u32>,
  }

  impl Status {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: TX buffer is full
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn txfull(&mut self) -> TxfullField {
        TxfullField::new(&mut self.reg)
    }

  /// Hardware description: RX buffer is full
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rxfull(&mut self) -> RxfullField {
        RxfullField::new(&mut self.reg)
    }

  /// Hardware description: TX FIFO is empty
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn txempty(&mut self) -> TxemptyField {
        TxemptyField::new(&mut self.reg)
    }

  /// Hardware description: TX FIFO is empty and all bits have been transmitted
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn txidle(&mut self) -> TxidleField {
        TxidleField::new(&mut self.reg)
    }

  /// Hardware description: RX is idle
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rxidle(&mut self) -> RxidleField {
        RxidleField::new(&mut self.reg)
    }

  /// Hardware description: RX FIFO is empty
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rxempty(&mut self) -> RxemptyField {
        RxemptyField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
  }
  type TxfullField<'a> = zermio::BitField<'a, 0, 1, u32, zermio::access::Read>;
  type RxfullField<'a> = zermio::BitField<'a, 1, 1, u32, zermio::access::Read>;
  type TxemptyField<'a> = zermio::BitField<'a, 2, 1, u32, zermio::access::Read>;
  type TxidleField<'a> = zermio::BitField<'a, 3, 1, u32, zermio::access::Read>;
  type RxidleField<'a> = zermio::BitField<'a, 4, 1, u32, zermio::access::Read>;
  type RxemptyField<'a> = zermio::BitField<'a, 5, 1, u32, zermio::access::Read>;
}



/// UART read data.  
pub use self::rdata::*;
mod rdata {

  use super::*;

  /// # RDATA fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | RDATA |  | [7:0] | false |true |
  pub struct Rdata {
    reg: zermio::Register<u32>,
  }

  impl Rdata {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: 
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rdata(&mut self) -> RdataField {
        RdataField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
  }
  type RdataField<'a> = zermio::BitField<'a, 0, 8, u32, zermio::access::Read>;
}



/// UART write data.  
pub use self::wdata::*;
mod wdata {

  use super::*;

  /// # WDATA fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | WDATA |  | [7:0] | true |false |
  pub struct Wdata {
    reg: zermio::Register<u32>,
  }

  impl Wdata {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: 
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn wdata(&mut self) -> WdataField {
        WdataField::new(&mut self.reg)
    }

    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
  }
  type WdataField<'a> = zermio::BitField<'a, 0, 8, u32, zermio::access::Write>;
}



/// UART FIFO control register.  
pub use self::fifo_ctrl::*;
mod fifo_ctrl {

  use super::*;

  /// # FIFO_CTRL fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | RXRST | RX fifo reset. Write 1 to the register resets RX_FIFO. Read returns 0 | [0:0] | true |false |
  /// | TXRST | TX fifo reset. Write 1 to the register resets TX_FIFO. Read returns 0 | [1:1] | true |false |
  /// | RXILVL | Trigger level for RX interrupts. If the FIFO depth is greater than or equal tothe setting, it raises rx_watermark interrupt. | [4:2] | true |true |
  /// | TXILVL | Trigger level for TX interrupts. If the FIFO depth is less than the setting, itraises tx_watermark interrupt. | [7:5] | true |true |
  pub struct FifoCtrl {
    reg: zermio::Register<u32>,
  }

  impl FifoCtrl {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: RX fifo reset. Write 1 to the register resets RX_FIFO. Read returns 0
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rxrst(&mut self) -> RxrstField {
        RxrstField::new(&mut self.reg)
    }

  /// Hardware description: TX fifo reset. Write 1 to the register resets TX_FIFO. Read returns 0
  ///
  /// Returns a BitField with Write permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn txrst(&mut self) -> TxrstField {
        TxrstField::new(&mut self.reg)
    }

  /// Hardware description: Trigger level for RX interrupts. If the FIFO depth is greater than or equal tothe setting, it raises rx_watermark interrupt.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rxilvl(&mut self) -> RxilvlField {
        RxilvlField::new(&mut self.reg)
    }

  /// Hardware description: Trigger level for TX interrupts. If the FIFO depth is less than the setting, itraises tx_watermark interrupt.
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn txilvl(&mut self) -> TxilvlField {
        TxilvlField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type RxrstField<'a> = zermio::BitField<'a, 0, 1, u32, zermio::access::Write>;
  type TxrstField<'a> = zermio::BitField<'a, 1, 1, u32, zermio::access::Write>;
  type RxilvlField<'a> = zermio::BitField<'a, 2, 3, u32, zermio::access::ReadWrite>;
  type TxilvlField<'a> = zermio::BitField<'a, 5, 3, u32, zermio::access::ReadWrite>;
}



/// UART FIFO status register.  
pub use self::fifo_status::*;
mod fifo_status {

  use super::*;

  /// # FIFO_STATUS fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | TXLVL | Current fill level of TX fifo | [7:0] | false |true |
  /// | RXLVL | Current fill level of RX fifo | [23:16] | false |true |
  pub struct FifoStatus {
    reg: zermio::Register<u32>,
  }

  impl FifoStatus {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Current fill level of TX fifo
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn txlvl(&mut self) -> TxlvlField {
        TxlvlField::new(&mut self.reg)
    }

  /// Hardware description: Current fill level of RX fifo
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rxlvl(&mut self) -> RxlvlField {
        RxlvlField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
  }
  type TxlvlField<'a> = zermio::BitField<'a, 0, 8, u32, zermio::access::Read>;
  type RxlvlField<'a> = zermio::BitField<'a, 16, 8, u32, zermio::access::Read>;
}



/// TX pin override control. Gives direct SW control over TX pin state.  
pub use self::ovrd::*;
mod ovrd {

  use super::*;

  /// # OVRD fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | TXEN | Enable TX pin override control | [0:0] | true |true |
  /// | TXVAL | Write to set the value of the TX pin | [1:1] | true |true |
  pub struct Ovrd {
    reg: zermio::Register<u32>,
  }

  impl Ovrd {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Enable TX pin override control
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn txen(&mut self) -> TxenField {
        TxenField::new(&mut self.reg)
    }

  /// Hardware description: Write to set the value of the TX pin
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn txval(&mut self) -> TxvalField {
        TxvalField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type TxenField<'a> = zermio::BitField<'a, 0, 1, u32, zermio::access::ReadWrite>;
  type TxvalField<'a> = zermio::BitField<'a, 1, 1, u32, zermio::access::ReadWrite>;
}



/// UART oversampled values.  
pub use self::val::*;
mod val {

  use super::*;

  /// # VAL fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | RX | Last 16 oversampled values of RX. Most recent bit is bit 0, oldest 15. | [15:0] | false |true |
  pub struct Val {
    reg: zermio::Register<u32>,
  }

  impl Val {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: Last 16 oversampled values of RX. Most recent bit is bit 0, oldest 15.
  ///
  /// Returns a BitField with Read permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn rx(&mut self) -> RxField {
        RxField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
  }
  type RxField<'a> = zermio::BitField<'a, 0, 16, u32, zermio::access::Read>;
}



/// UART RX timeout control.  
pub use self::timeout_ctrl::*;
mod timeout_ctrl {

  use super::*;

  /// # TIMEOUT_CTRL fields.  
  /// | Field name      | Description  | Offset | Write | Read| 
  /// | :---               | :---         | :---   | :--   | :-- |
  /// | VAL | RX timeout value in UART bit times | [23:0] | true |true |
  /// | EN | Enable RX timeout feature | [31:31] | true |true |
  pub struct TimeoutCtrl {
    reg: zermio::Register<u32>,
  }

  impl TimeoutCtrl {
    pub fn new(addr: u32) -> Self {
      Self {
        reg: zermio::Register::<u32>::new(addr as usize),
      }
    }
  /// Hardware description: RX timeout value in UART bit times
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn val(&mut self) -> ValField {
        ValField::new(&mut self.reg)
    }

  /// Hardware description: Enable RX timeout feature
  ///
  /// Returns a BitField with ReadWrite permissions, providing the following functions:
  /// | Method                | Description                                     |
  /// | :---                  | :---                                            |
  /// | **`get()`**           | Returns the current value of the field.         |
  /// | **`is_set()`**        | Returns `true` if the bit is 1.                 |
  /// | **`write(val)`**      | Writes a multi-bit `val` to the field.          |
  /// | **`clear()`**         | Sets all bits in the field to 0.                |
  /// | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  |
  /// | **`set()`**           | Sets a single-bit field to 1.                   |
  /// | **`reset()`**         | Sets a single-bit field to 0.                   |
  /// | **`toggle()`**        | Inverts the current state of a single-bit field.|
  /// | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   |
  /// | **`mask()`**          | Returns the bitmask for this field.             |
  /// | **`max()`**           | Returns the maximum value this field can hold.  |
  ///
    pub fn en(&mut self) -> EnField {
        EnField::new(&mut self.reg)
    }

    /// Run a load instruction to read from MMIO
    pub fn fetch(&mut self) -> &mut Self {
      self.reg.fetch();
      self
    }
    /// Run a store instruction to write the MMIO
    pub fn commit(&mut self) {
      self.reg.commit()
    }
    /// Call action to update the inner self, then run a store instruction to write it to the MMIO
    pub fn write<F>(&mut self, action: F)
    where
      F: FnOnce(&mut Self),
    {
      action(self);
      self.reg.commit();
    }
    /// Run a load instruction to read from the MMIO, call action, then run a store instruction 
    /// to write it to the MMIO
    pub fn update<F>(&mut self, action: F)
    where
        F: FnOnce(&mut Self),
    {
      self.reg.fetch();
      self.write(action);
    }
  }
  type ValField<'a> = zermio::BitField<'a, 0, 24, u32, zermio::access::ReadWrite>;
  type EnField<'a> = zermio::BitField<'a, 31, 1, u32, zermio::access::ReadWrite>;
}
