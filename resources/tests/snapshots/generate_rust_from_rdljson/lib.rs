
/*
 * File autogenerated by the test.
 */

/* The best way to read and explor this documentation is by rendering it with:*/
/*`cargo doc --open`*/

#![no_std]

//! # sonata Zermio
//!
//! `zermio` provides zero-cost abstractions for Memory-Mapped I/O (MMIO) access,
//! focusing on performance and safety.
//!
//! ## Getting Started
//!
//! Following the Peripheral Access Crate (PAC) convention, you can take ownership 
//! of hardware peripherals by calling **`take()`**. For contexts where ownership 
//! is already managed or must be bypassed, the unsafe, infallible **`steal()`**
//! function is available.
//!
//! ## The Register Model
//!
//! Peripherals are modeled as structs where each member represents a specific register.
//! Access is controlled functions: a register provides specific methods only if it 
//! is hardware-defined as readable or writable.
//!
//! ### Lazy MMIO Operations
//!
//! To maximize performance and reduce unnecessary loads/stores, `zermio` employs 
//! a lazy access pattern:
//!
//! * **`fetch()`**: Explicitly loads the value from physical MMIO into the local register struct.
//! * **`commit()`**: Explicitly writes the current local value back to the physical MMIO.
//!
//! ### Shorthand API: `write` and `update`
//!
//! For convenience, `zermio` provides higher-level methods that handle the fetch/commit 
//! lifecycle using closures:
//!
//! * **`write(|reg| ...)`**: Creates a new value and commits it to memory.
//! * **`update(|reg| ...)`**: Fetches the current value, allows modification, and 
//!     commits the result back to memory in a single logical block.
//!
//! ## Register Fields
//!
//! Additionally, every register provides access to specific **bitfields** through a function 
//! with the same name as the field. Each bitfield is modeled as a generic `Bitfield` type, 
//! with access strictly controlled by hardware-defined read/write permissions.
//! 
//!
//! ### Bitfield API Reference
//!
//! These methods operate on the **local register buffer**. To reflect changes in the hardware, 
//! **`commit()`** must be called (or the methods must be used within an **`update`** or **`write`** closure).
//!
//! | Method                | Description                                     | Type  | HW Access | 
//! | :---                  | :---                                            | :---  | :-|
//! | **`get()`**           | Returns the current value of the field.         | `u32` | R |
//! | **`is_set()`**        | Returns `true` if the bit is 1.                 | `bool`| R |
//! | **`write(val)`**      | Writes a multi-bit `val` to the field.          | `u32` | W |
//! | **`clear()`**         | Sets all bits in the field to 0.                | -     | W |
//! | **`write_mask(val)`** | Sets only the bits that are high (1) in `val`.  | `u32` | W |
//! | **`set()`**           | Sets a single-bit field to 1.                   | `bool`| W |
//! | **`reset()`**         | Sets a single-bit field to 0.                   | `bool`| W |
//! | **`toggle()`**        | Inverts the current state of a single-bit field.| `bool`| W |
//! | **`assign(val)`**     | Sets a single-bit field to the boolean `val`.   | `bool`| W |
//! | **`mask()`**          | Returns the bitmask for this field.             | `u32` | - |
//! | **`max()`**           | Returns the maximum value this field can hold.  | `u32` | - |
//!
//! ## Example
//! The following example is for the Opentitan Uart.
//! ``` rust
//! let peri = zermio::sonata::Peripherals::take().unwrap();
//! let mut uart = peri.uart;
//! let nco = (BAUD << 20) / CPU_CLOCK_HZ as u64;
//! uart.ctrl.write(|ctrl| {
//!     ctrl.nco().write(nco as u32);
//!     ctrl.tx().set();
//!     ctrl.rx().set();
//! });
//!   
//! let txt = "Hello from SONATA";
//! for c in txt.as_bytes(){
//!     while uart.status.fetch().txfull().is_set() {}
//!     uart.wdata.wdata().write(*c as u32).commit();
//! }
//! loop{}
//! ```
//! See the documentation at [`crate::sonata`] for all the peripherals available.

pub mod zermio;
pub mod sonata;
pub mod gpio;
pub mod pwm;
pub mod xadc;
pub mod timer;
pub mod uart;
pub mod i2c;
pub mod spi;

