zermio (ZERo cost Memory mapped Input and Output) is a toolkit based on svd2rust that can ingest SVDs files and generate C++ abstractions to write and read mmios in a very efficiente way.

The Generated abstractions are based on C++20 standard, using powerfull and efficient features such as `concepts` and `costexpr` to deliver the size and performance of equivalent C drivers.

In tests with gcc 15 and clang 19 with optimization `O2` the abstraction was completelly inlined to a few instructions.

## Generating C++ register interfaces.
Generating the C++ MMIO abstractions for Ibex demo system with the command:

```sh
wget https://raw.githubusercontent.com/lowRISC/ibex-demo-system/refs/heads/main/data/ibex.svd -O /tmp/ibex.svd
cargo run import-svd --svd /tmp/ibex.svd export-cpp --dir /tmp/ --periph-dir /tmp/
```

Customizing the license header on each generated source file.

```sh
cargo run import-svd --header-file=/tmp/header.md --svd /tmp/ibex.svd export-cpp --dir /tmp/ --periph-dir /tmp/proj/mmio/
```

## Examples

This is a simple example of how to write an UART driver using the register interface generate by the previous section.
```c++
#include "mmio/uart.hh" // Autogenerated file.
#include "mmio/sonata_system_platform.hh" // Autogenerated file.

class Uart {
// Use C++ strong typing to constrain the acceptable addresses.
  const platform::Uart base_addr;

 public:
  constexpr Uart(
    platform::Uart base_addr,
    std::size_t sys_freq,
    std::size_t baud = 921600) : base_addr(base_addr) {

  // Create a local instance of the register interface. The local scope helps the compiler
  // to opmize and inline everything.
    mmio::uart::Uart base(base_addr);

    std::size_t nco = (std::size_t)(((uint64_t)baud << 20) / sys_freq);

    // Use the functions provided by the autogenerated interface to prepare the CTRL register
    // with the desired value.
    base.ctrl.nco.write(nco);
    base.ctrl.tx.set();
    base.ctrl.rx.set();

    // Write the changes to the mmio.
    base.ctrl.commit();
  }

  uint8_t read_byte() {
  // Create a local instance of the register interface. The local scope helps the compiler
  // to opmize and inline everything.
    mmio::uart::Uart base(base_addr);

  // Read the RDATA mmio with `fetch` and retrieve the field VALUE with `get`. 
    return base.rdata.fetch().value.get();
  }

  void write_byte(uint8_t c) {
  // Create a local instance of the register interface. The local scope helps the compiler
  // to opmize and inline everything.
    mmio::uart::Uart base(base_addr);

    // Read the STATUS mmio with `fetch` and check whether the field TXFULL is set with `is_set`. 
    while (base.status.fetch().txfull.is_set()) {
    };

    // Prepare the register WDATA field VALUE with `write`, than write it to the mmio with
    // `commit`. 
    base.wdata.value.write(static_cast<std::size_t>(c)).commit();
  }
};
```
