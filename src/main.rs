// Copyright (c) 2025 Douglas Reis.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0

use zermiolib::generator;

use clap::{Parser, Subcommand};
use std::path::PathBuf;
use std::str::FromStr;

static FILE_HEADER: &str = r#"
/*
 * This file is autogenerated by the tool zermio.
 */
"#;

#[derive(Subcommand, Debug)]
enum Input {
    ImportSvd {
        /// A path to a svd file
        #[arg(long, short, value_parser =  PathBuf::from_str)]
        svd: PathBuf,
        /// A path to a text with containing the licence header that should be added to every
        /// generated file.
        #[arg(long, short, value_parser =  PathBuf::from_str)]
        header_file: Option<PathBuf>,
        #[command(subcommand)]
        output: Output,
    },
}

#[derive(Subcommand, Debug)]
enum Output {
    ExportCpp {
        /// A dir to output the peripheral implementation.
        #[arg(long, short, value_parser =  PathBuf::from_str)]
        dir: PathBuf,

        /// A dir to output the header with the peripheral addresses.
        #[arg(long, short, value_parser =  PathBuf::from_str)]
        periph_dir: Option<PathBuf>,
    },
}

// Define a struct to represent command-line options
#[derive(Parser, Debug)]
#[command(version, about, long_about = None)]
struct Args {
    #[command(subcommand)]
    input: Input,
}

fn main() -> anyhow::Result<(), String> {
    let args: Args = Args::parse();

    let (device, output, header) = match args.input {
        Input::ImportSvd {
            svd,
            output,
            header_file,
        } => {
            if !svd.exists() {
                return Err("Svd does not exist!".to_string());
            }

            println!("Loading the {}...", svd.display());
            let xml = std::fs::read_to_string(&svd).unwrap();
            let svd_rs = svd_parser::parse(&xml).unwrap().try_into()?;
            let header = if let Some(header_file) = header_file {
                if !header_file.exists() {
                    return Err("File with header does not exist!".to_string());
                }
                std::fs::read_to_string(header_file).unwrap() + FILE_HEADER
            } else {
                FILE_HEADER.into()
            };
            (svd_rs, output, header)
        }
    };

    match output {
        Output::ExportCpp { dir, periph_dir } => {
            if !dir.is_dir() {
                return Err("Output path is not a dir!".to_string());
            }
            let periph_dir = periph_dir.unwrap_or(dir.clone());
            if !periph_dir.is_dir() {
                return Err("Addresses path is not a dir!".to_string());
            }

            generator::cpp::generate(&device, dir, periph_dir, &header).unwrap();
        }
    }

    Ok(())
}
